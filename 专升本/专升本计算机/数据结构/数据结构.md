# 基本概念

数据：数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。

数据元素：**数据元素是数据的基本单位**，通常作为一个整体进行考虑和处理。一个数据元素可由若干数据项组成，**数据项是构成数据元素的不可分割的最小单位**。例如，学生记录就是一个数据元素，它由学号、姓名、性别等数据项组成。

数据对象：数据对象是具有相同性质的数据元素的集合，是数据的一个子集。例如，一个班的所有学生

数据类型：数据类型是一个值的集合和定义在此集合上的一组操作的总称。

* 原子类型：其值不可再分的数据类型。
* 结构类型：其值可以再分解为若干成分(分量)的数据类型。
* 抽象数据类型(Abstract Data Type)：抽象数据类型(ADT)描述了数据的逻辑结构和抽象运算，通常用(数据对象，数据关系，基本操作集)这样的三元组来表示从而**构成一个完整的数据结构**定义。例如：线性表、集合、树、图等。

数据结构：数据结构是相互之间存在一种或多种特定关系的数据元素的集合。在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构。**数据结构三要素**：逻辑结构、物理(存储)结构、数据的运算

数据的逻辑结构：逻辑结构是指数据元素之间的逻辑关系，即**从逻辑关系上描述数据。与数据的存储无关**，是独立于计算机的(为了简化难度，人为想象出来的)。数据的逻辑结构**分为线性结构和非线性结构**两种类型，**线性表**是典型的线性结构。**集合**、**树**和**图**是典型的非线性结构。(除了树、图、集合都是线性结构)（”熟鸡兔“）

数据的存储结构：存储结构是指数据结构在计算机中的表示(又称映像)，也称物理结构。它包括**数据元素的表示**和**关系的表示**。数据的存储结构是用计算机语言实现的逻辑结构，它依赖于计算机语言。数据的存储结构主要有**顺序存储、链式存储、索引存储和散列存储**。

* 区分顺序存储与链式存储：顺序存储在物理位置上是连续的，而链式在物理位置上的不是连续的。

算法是**对特定问题求解步骤的一种描述**，它是指令的有限序列，其中的每条指令表示一或多个操作。

一个算法还具有下列**5个重要特性**：

* 有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。
* 确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。
* 可行性。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。
* 输入。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。
* 输出。一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。

设计一个好的算法应考虑达到以下目标(以下不属于算法特性)：

* 正确性。算法应能够正确地解决求解问题。
* 可读性。算法应具有良好的可读性，以帮助人们理解。
* 健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。

**算法效率的度量是通过时间复杂度和空间复杂度来描述的**

时间复杂度：一个语句的频度是指该语句在算法中被重复执行的次数。算法中所有语句的频度之和记T(n)，它是该算法问题规模n 的函数，时间复杂度主要分析T(n)的数量级。算法中基本运算(深层循环内的语句)的频度与 T(n)同数量级，通常采用算法中基本运算的频度f(n)来分析法的时间复杂度。因此，算法的时间复杂度记为：T(n)=O(f(n))。如何推导出时间复杂度呢?

步骤：

* 一层循环：求出最内层循环体的执行次数，以次数为T(n)，逐次表示出1、2、3、...、k次下的循环变量值，从而解出次数k与循环变量的函数关系式k=，则O(n)=k
* 二层循环：分析外层变量变化下内层次数变化，分别计算出内外层次数，最后相乘得到

有如下几个原则：

* 如果运行时间是常数量级，用常数1表示；例：$T(n)=3$，则$T(n)=O(1)$
* 只保留时间函数中的最高阶项，如果最高阶项存在，则省去最高阶项前面的系数。例：$T(n)=0.5n^2+0.5n$，则$T(n)=O(n^2)$

时间复杂度大小关系：$O(1) < O(\log n) < O(n) < O(n\log n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)$

例子：一层循环
```C
int i=1;
while(i<=n){
	i=i*2;
}
```

| 次数T | 循环变量i |
| --- | ----- |
| 1   | 2     |
| 2   | 4     |
| 3   | 8     |
| ... | ...   |
| k   | $2^k$ |

* 分析：最后一次k时，$i=2^k$，解得$k=\log_2{i}$，所以$O(n)=\log_2{n}$

例子：二层循环
```C
for(i=1;i<n;i++){
	m=1;
	while(m<n){
		m=m*2;
	}
}
```

* 分析：当外层i=1时，内层执行$\log_2{i}$次，当外层i=2时，内层执行$\log_2{i}$次，...，外层i=n-1时，内层执行$\log_2{i}$次，所以总共执行$(n-1)(\log_2{i})$次，所以$O(n)=n\log_2{n}$

空间复杂度(了解)：算法的空间复杂度 S(n)定义为该算法所耗费的存储空间，它是问题规模n的函数。记为S(n)= O(g(n))。

* 一个程序在执行时除需要存储空间来存放本身所用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间。若输入数据所占空间只取决于问题本身，和算法无关，则只需分析除输入和程序之外的额外空间。算法原地工作是指算法所需的辅助空间为常量，即0(1)。

# 线性表

定义：线性表是具有相同数据类型的n(n20)个数据元素的有限序列，其中n为表长，当n=0时线性表是一个空表。若用L命名线性表，则其一般表示为L=(a₁,a₂, ... ,aₙ)

位序：数据元素在线性表中的排序，从1开始

前驱和后继：除第一个元素外，每个元素有且仅有一个前驱；除最后一个元素外，每个元素有且仅有一个后继

注意：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。顺序表和链表是指
存储结构，两者属于不同层面的概念，因此不要将其混淆。

顺序存储和链式存储的特点、优点、缺点：

* 特点：
	* 顺序存储：随机访问、占用连续的存储空间。
	* 链式存储：不可随机访问，只能顺序遍历，支持动态分配存储空间(链式存储地址可能连续也可能不连续)。
* 优点：
	* 顺序存储：可随机访问，存储密度高。
	* 链式存储：大量数据插入删除时，无需移动元素，比较灵活
* 缺点：
	* 顺序存储：增加或删除时，可能会造成大量元素移动(在表尾除、插入不用移动)
	* 链式存储：存储密度低，不可随机访问，代码设计较难。


## 顺序表

定义：线性表的顺序存储又称顺序表。它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。

线性表是一个**有限序列，可以为空**

顺序表结构：类似数组

特点：

* 最主要的特点是**随机访问**，即通过首地址和元素序号可在时间O(1)内找到指定的元素。
* **存储密度高**，每个结点只存储数据元素。
* **逻辑上相邻的元素物理上也相邻**，所以插入和删除操作需要移动大量元素

顺序表上基本操作的实现：

1. 插入操作：
	* 最好情况：在表尾插入，元素后移语将不执行，时间复杂度为O(1)。
	* 最坏情况：在表头插入，元素后移语句将执行n次，时间复杂度为O(n)。
	* 平均情况：在长度为n的线性表中插入一个结点时，所需移动结点的平均次数为$\frac{n}{2}$。线性表插入算法的平均时间复杂度为O(n)。
		* 最好为最后一个不移动，最坏为第一个移动n次
2. 删除操作：
	* 最好情况：删除表尾元素，无须移动元素，时间复杂度为O(1)。
	* 最坏情况：删除表头元素，需移动除表头元素外的所有元素，时间复杂度为O(n)
	* 平均情况：在长度为n的线性表中删除一个结点时，所需移动结点的平均次数为$\frac{n-1}{2}$。线性表删除算法的平均时间复杂度为O(n)。
		* 最好为删除表尾不移动，最坏为删除表头元素移动n-1个
3. 按值查找：
	* 最好情况：查找的元素就在表头，仅需比较一次，时间复杂度为O(1)。
	* 最坏情况：查找的元素在表尾(或不存在)时，需要比较n次，时间复杂度为O(n)。
	* 平均情况：在长度为n的线性查找e元素平均比较的次数为$\frac{n+1}{2}$。线性表按值查找算法的平均时间复杂度为O(n)。

## 链表

顺序表可以随时存取表中的任意一个元素，但插入和删除操作需要移动大量元素。链式存储线性表时，不需要使用地址连续的存储单元，即**不要求逻辑上相邻的元素在物理位置上也相邻**，它通过“链”建立起数据元素之间的逻辑关系因此插入和删除操作不需要移动元素，而只需修改指针，但也会失去顺序表可随机存取的优点。

### 单链表

线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素。**所有结点通过指针的链接组成链表**。

结点结构：`data + next`

* data：为数据域，存储数据元素
* next：为指针域，存放其后继结点的地址

对比顺序表：

* **便于插入和删除**
* 利用单链表可以解决顺序表需要大量连续存储单元的缺点，但单链表附加指针域，也存在浪费存储空间的缺点(和顺序表比较，链表的存储空间利用率稍低一些)。
* 由于单链表的元素离散地分布在存储空间中，所以单链表是**非随机存取的存储结构**，不能直接找到表中某个特定的结点。
* **查找某个特定的结点时，需要从表头开始遍历，依次查找**。

表示：通常用头指针来标识一个单链表，单链表 L，头指针为 NULL 时表示一个空表。

头结点：为了操作上的方便，在单链表第一个结点之前附加一个结点，称为头结点。头结点的数据域可以不设任何信息，也可以记录表长等信息。头结点的指针域指向线性表的第一个元素结点。

单链表定义：

* 带头结点：方便操作的实现
![[Pasted image 20251016213220.png]]
* 不带头结点：
![[Pasted image 20251016213242.png]]
* 不管带不带头结点，头指针都是指向第一个结点

判断单链表是否为空：

* 带头结点的单链表：`L->nextF==NULL`
* 不带头结点的单链表：`L==NULL`

==基本操作==

1.建立单链表

含义：于初始化列表操作之后，用于往空链表插入数据结点形成完整的链表

* 初始化的头结点的指针域为`L->next=NULL`

头插法建立单链表(带头结点)：![[Pasted image 20251016214833.png]]

* 特点：采用头插法建立单链表时，读入数据的顺序与生成的链表中的元素的顺序是相反的。

核心代码：
```C
S->data=x;
S->next=L->next;
L->next=S;
```

时间复杂度：每个结点插入的时间为O(1)，设单链表长为n，则总时间复杂度为O(n)。

尾插建立单链表(带头结点)：![[Pasted image 20251016215846.png]]

* r为新增表尾指针
* 特点：读入的数据和生成的链表中的元素顺序一致。

核心代码：
```C
S->data=x;
r->next=S;
r=S;
S=r;
```

时间复杂度：每个结点插入的时间为O(1)，设单链表长为n，则总时间复杂度为O(n)。

2.插入结点操作

含义：插入结点操作将值为x的新结点插入到单链表的第i个位置上。

思路：先检查插入位置的合法性然后找到待插入位置的前驱结点，即第i-1个结点，再在其后插入新结点

![[Pasted image 20251016224133.png]]

核心代码：
```C
S->next=p->next;
p->next=S
```

时间复杂度：本算法主要的时间开销在于查找第 i-1个元素，时间复杂度为O(n)

3.删除结点操作

含义：删除结点操作是将单链表的第i个结点删除。

思路：先检查删除位置的合法性，后查找表中第i-1个结点，即被删结点的前驱结点，再将其删除。

![[Pasted image 20251016224832.png]]

核心代码：
```C
p->next=q->next;
或
p->next=p->next->next
free(q);
```

==特记==

链表与顺序表在输出表中所有元素值的时间复杂度一样

### 双链表

要访问单链表的某个结点时，只能从头开始遍历。为了克服单链表的上述缺点，引入了双链表。

结点结构：`prior + data + next`

双链表定义(只有带头结点)：![[Pasted image 20251017014329.png]]

==基本操作==

1.插入结点操作

![[Pasted image 20251017014422.png]]

核心代码：
```C
s->next=p->next;
p->next->prior=s;
s->prior=p;
p->next=s;
```

2.删除结点操作

图有错误(p和q标识)![[Pasted image 20251017020043.png]]

核心代码：
```C
p->next=q->next;
q->next->prior=p;
free(q);
```

### 循环链表

==循环单链表==

循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，改为指向头结点从而整个链表形成一个环。

判空：空条件不是头结点的指针是否为空，而是它是否等于头指针。`heda->next==head`

结构：循环单链表**不设头指针而仅设尾指针**，从而使得操作效率更高。其原因是，若设的是头指针，对表尾进行操作需要O(n)的时间复杂度，而若设的是尾指针r，r->next即为头指针，**对表头与表尾进行操作都只需要O(1)的时间复杂度**。

操作：循环单链表的插入、删除算法与单链表的几乎一样，不同的是这些操作是在**表尾**进行的。

优点：在单链表中只能从表头结点开始往后顺序遍历整个链表，而循环单链表可以**从表中的任意一个结点开始遍历整个链表**。

==循环双链表==

带头结点的双向循环链表判空条件：`L-prior==L->next==L`（其中一个即可）

## 栈和队列

### 栈(Stack)

定义：栈(Stack)是只允许在**一端进行插入和删除操作的线性表**

栈的操作是后进先出Last In First Out(LIFO)。n个元素进栈，则有$C_{2n}^n$种出栈结果($C_n^m=\frac{n!}{m!(n-m)!}$)

栈的基本操作：

* Push 进栈，若栈未满，则将元素加入使之成为新栈顶。
* Pop出栈，若非空，则弹出栈顶元素，并把元素返回。

==顺序栈==

采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素

栈顶指针：S.top。初始化设置为-1时，则指向当前栈顶元素；初始化设置为0时，则指向栈顶元素的下一个存储单元

栈底指针：S.base，当值为NULL时，表明该栈结构不存在

栈空条件：`S.top==0` 或 `S.top==-1` 或 `base==top`

栈满条件：`S.top==MaxSize` 或 `S.top==MaxSize-1`

进栈代码：栈顶指向栈顶元素时，栈顶指针+后放入数据；栈顶指针指向栈顶元素的下一个元素时，放入数据后栈顶指针+1

出栈操作：栈顶指向栈顶元素时，拿取数据后栈顶指针-1；栈顶指针指向栈顶元素的下一个元素时，栈顶指针-1后拿取数据

==共享栈==

![[Pasted image 20251020163935.png]]

优点：节省存储空间，降低发生上溢的可能

==链栈==

定义：采用链式存储的栈称为链栈，通常采用**单链表实现**，并规定所有**操作都是在单链表的表头进行**。这里规定链栈**没有头结点，Lhead指顶元素**。

优点：链栈的优点是便于多个栈共享存储空间和提高其效率，且**不存在栈满上溢**的情况。

### 队列(Queue)

定义：只允许**一端插入、一端删除的线性表**，操作是先进先出First In First Out(FIFO)

==顺序队列==

![[Pasted image 20251020170737.png]]

* 队头：出队的一端
* 队尾：进队的一端
* 队头和队尾指针都在向右走，走到一起时即为空队列

队头指针：Q.front，指向队头元素

队尾指针：Q.rear，指向队尾元素的下一位或指向队尾元素

初始状态：`Q.front==Q.rear==0`

队空条件：`Q.front==Q.rear`

进队操作：队不满时，先赋值给队尾元素，再将队尾指针加1

出队操作：队不空时，先取队头元素，再将队头元素加1

理解：刚开始时，front和rear都是0，但是后面进队或出队后两指针都一直再增加，只有`front==rear`时，队列元素才为空

==循环队列==

![[Pasted image 20251020233649.png|335]]

* 由于`Q.front==Q.rear`无法判断队列为空或者满，所以规则少用一个存储单元(以下操作或判断都是在少一个存储单元的情况)
* rear为指向队尾元素的下一个元素，并且都是按照索引操作，此时才能满足%Maxsize每个位都进入循环
* 理解：整个循环一直在索引位上入队或出队，并不一定从索引0的位置开始有元素

队满条件：`(Q.rear+1)%MaxSize==Q.front`

队空条件：`Q.front==Q.rear`

队尾进队：`Q.rear=(Q.rear+1)%Maxsize`

队头出队：`Q.front=(Q.front+1)%Maxsize`

队列元素个数：`(Q.rear-Q.front+MaxSize)%Maxsize`

* 理解：循环队列的元素都在循环移动，可能rear走到了下一个循环，索引值比front小，所以+一个MaxSize保证`Q.rear-Q.front`不为负数
* 特殊：
	* 当队尾指针指向队尾元素时，`(Q.rear-Q.front+MaxSize+1)%Maxsize`
	* 当队头指针指向队头元素的前一个，队尾指针指向队尾元素时，公式仍适用

==链队列==

定义：采用链式存储的队列，实际上是一个同时带有队头指针和队尾指针的单链表

![[Pasted image 20251021000550.png]]

* 注意：与顺序存储不一样，队尾指针是指向队尾元素，队头指针仍指向队头元素

队空条件：`Q.front==NULL`且`Q.rear==NULL`

优点：不存在队列满且产生溢出问题

==特记==

栈和队列的主要区别在于(插入、删除操作的限定不一样)

执行函数时，其局部变量一般采用(栈结构)进行存储

执行(广度优先搜索图)操作时，需要使用队列作为辅助存储空间

### 栈和队列的应用

中缀表达式：运算符以中缀形式处于操作数的中间。例：3+4

前缀表达式(波兰表达式)：运算符写在操作数之前。例如：+34

后缀表达式(逆波兰表达式)：运算符写在操作数之后。例如：34+

中缀→前缀：按每步运算加括号，括号为(数 运算符 数)，加完后将每个括号中的运算符放在操作数之前(或之后)，最后去掉括号

* 例：`1+2*3/18*21`中缀转后缀
	* 加括号：`(1+(((2*3)/18)*21))`
	* 放运算符：`(1(((2 3*)18/)21*)+)`
	* 拆括号：`1 2 3 * 18 / 21 * +
* 注意：当表达式自带括号时，仍按以上步骤即可

前缀→中缀：从后往前扫描，每扫描一个运算符，就添加一个括号，将该运算符和其之后的两个数括起(运算符 数 数)，全部符号扫描后将每个括号中的前运算符放到中间，最后去除**不影响运算顺序**的括号

* 例：` - * A B + C D`
	* 加括号：`(-(*AB)(+CD))`
	* 运算符放中间：`((A*B)-(C+D))`
	* 去掉多余括号：`(A*B)-(C+D)`

后缀→中缀：从前往后扫描，每扫描一个运算符，就添加一个括号，将该运算符和其之前的两个数括起(数 数 运算符)，全部符号扫描后将每个括号中的后运算符放到中间，最后去除**不影响运算顺序**的括号

* 例：`A B C * + D -`
	* 加括号：`((A(BC*)+)D-)`
	* 运算符放中间：`((A+(B*C))-D)`
	* 去掉多余括号：`A+B*C-D`

# 树

## 树的概念

树的定义树是非线性的数据结构，本质是结点的有限集。

树的定义有以下两点：

* 有一个特殊的结点，称为根结点，它是同一棵树中除本身外所有结点的祖。
* 当结点数量大于1时，其余结点可分为若干个互不相交的有限集，其中每个集合也可以看作一颗树，称之为根的子树，若树的结点为0，该树为空树。

树作为一种逻辑结构，具有以下两个特点：

* 树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。
* 树中所有结点可以有零个或多个后继，n树适合于表示具有层次结构的数据。在n个结点的树中有n-1条边。

树的术语：

* 结点的度：该结点的子女数量，不算孙
* 树的度：树中各结点的度的最大值
* 叶子结点：也称终端结点，度为0
* 树的层次：从上往下，根结点到叶子结点
* 结点的深度：从根节点数到本结点(1开始)
* 结点的高度：从叶子节点数到本节点(1开始)，多条路径数最长的

有序树和无序树：树中结点的各子树从左到右是有次序的，不能互换，称该树为有序树，
否则称为无序树。

森林：棵互不相交的树的集合。下图是由三棵树构成的森林![[Pasted image 20251029140605.png|409]]

### 树的存储方式

双亲表示法：取一块连续的内存空间(**数组**)，存储为：`本身+父结点索引`

例如，使用双亲表示法存储图(a)中的树结构时，数组存储结果为(b)：
![[Pasted image 20251102163716.png|495]]

孩子表示法：将树中的每个结点的孩子结点排列成一个线性表，用**链表**存储起来。对于含有n个结点的树来说，就会有n个单链表，将n个单链表的头指针存储在一个线性表中，这样的表示方法就是孩子表示法。如果结点没有孩子(例如叶子结点)，那么它的单链表为空表。

例如，使用孩子表示法存储图(a)中的树结构时，链式存储结果为(b)：
![[Pasted image 20251102163819.png|565]]

孩子双亲表示法：结合上面两种方法(数组+链表)

例如，使用孩子双亲表示法存储图(a)中的树结构时，链式存储结果为(b)：
![[Pasted image 20251102164042.png]]

孩子兄弟表示法：使用链式存储结构存储普通树。链表中每个结点由3部分组成`孩子指针域+数据域+兄弟指针域`，其中孩子指针域，表示指向当前结点的第一个孩子结点，兄弟结点表示指向当前结点的下一个兄弟结点。

* 通过孩子兄弟表示法，普通树转化为了二叉树，所以孩子兄弟表示法又被称为“二叉树表示法”或者“二叉链表表示法”

例如，用孩子兄弟表示法存储图(a)中的树结构时，链式存储结果为(b)：
![[Pasted image 20251102165114.png]]

## 二叉树的概念

二叉树的特点：

* 每个结点最多有两颗子树
* 左子树与右子树有顺序，即使只有一个子树，也需要去判断是左子树还是右子树。

n个结点可以构成$\frac{C_{2n}^n}{n+1}$种不同形态的二叉树($C_n^m=\frac{n!}{m!(n-m)!}$)，例3个结点可以构成5种不同形态的二叉树

五种特殊的二叉树：

* 满二叉树：如果一棵二又树的所有分支结点都存在左右子树，并且所有的叶子结点都在同一层，则称之满二叉树
* 完全二叉树：由满二叉树从下往上、从右到左，逐个删除结点构成的二叉树(满二叉树也是完全二叉树)
* 二叉排序树：左子树上所有结点的关键字均小于根结点的键字，右于树上的所有结点的关键字均大于根结点的排序树，左右子树又是一棵二叉排序树。
* 平衡二叉树：是一种特殊的二叉排序树，树上任一结点的左子树和右子树的高度之差不超过 1。
* 哈夫曼树(最优二叉树)：当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”
* 当有n个结点构成二叉树时，每层一个结点构成的树最高，构成完全二叉树最低

性质：

* 二叉树第i层上至多有$2^{i-1}$个结点
* 高度(深度)为k的二叉树至多有$2^k-1$个结点
* 二叉树中，总结点数与0、1、2度结点数关系：$n_{总}=n_0+n_1+n_2$；并且$n_0=n_2+1$
* 完全二叉树中，度为1的结点数只能有0或1个，故总结点数与总叶子结点数关系：$n_叶=n_总/2(n为偶数)$或$n_叶=(n_总+1)/2(n为奇数)$；总结点数与度为2结点数关系：$n_叶=n_总/2(n为偶数)$或$n_叶=(n_总-1)/2(n为奇数)$
* 对完全二叉树按从上到下、从左到右的顺序依次编号 1,2.,n，则有以下关系：
	* 结点为i的左子节点为i/2(偶数)，右子结点为i/2+1(奇数)
	* 结点为i所在的层次(深度)为$\lfloor\log_2i\rfloor+1$

### 二叉树的遍历

深度(优先)遍历：分为先根遍历、中根遍历、后根遍历

![[Pasted image 20251029230526.png|238]]

先序(根)遍历(根左右)：A B D H I E C F J G

中序(根)遍历(左根右)：H D I B E A F J C G

后序(根)遍历(左右根)：H I D E B J F G C A

遍历理解：从根结点开始，每次都对当前节点进行一次遍历，如果从该结点的遍历时，有前结点没有遍历到，则在再前结点为根结点进行遍历，依次循环

层次遍历：从低层到高层，再从每层的左结点到右结点

* 层次遍历需要队列的支持

题型：根据二叉树的两种遍历，求另一种遍历

* 只有先序、中序或中序、后序能确定唯一二叉树

方法：根据两种遍历画出原树图，然后再进行另一种遍历

* 画图时主要是找到树与子树的根结点，从而确定其左右子结点。每一小部分都必有根结点

### 树、森林的遍历

树遍历思路：将树转换为二叉树进行遍历

* 转换后的二叉的先序遍历为树的先序遍历，中序遍历为树的后序遍历

森林遍历思路：先将各棵树转换为二叉树，然后在将各二叉树拼接成一棵新二叉树，最后进行遍历

* 转换后的二叉树的先序遍历为森林的先序遍历，中序遍历为森林的中序遍历

树转换为二叉树：每个结点只保留第一个子结点作为左子结点，其余断开，断掉的结点再作为同层中其左边第一个结点的右子结点

* 结果：右兄弟变右孩子

二叉树拼接成一个树：从第二棵二叉树开始，每一个根结点作为其左棵树的根节点的右子结点进行连接

![[Pasted image 20251029233405.png|336]]

### 二叉树的存储结构

==顺序存储==

顺序存储：将二叉树中的每一个结点按照满二叉树的**层次**序号进行编号，将空着的编号进行留空，将结点中的数据存入**数组**对应编号中，这样可以做成二叉树的顺序存储结构。如图所示，顺序存储结构浪费存储空间，所以顺序存储结构只适用于完全二叉树。

![[Pasted image 20251102154113.png|565]]

==链式存储==

链式存储结构：首先树结点定义与结点定义类似，结构为`rchild(左孩子)+数据域+rchild(右孩子)`（二叉链存储结构）

![[Pasted image 20251102171949.png|453]]

==线索二叉树==

定义：以二叉链表作为二叉树的存储结构，对于n个结点的二叉树，在二叉链存储结构中有 n+1个空链域（总2n-有的n+1)，利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为**线索**，加上线索的二叉树称为线索二叉树。

二叉树的线索化：对二叉树以某种遍历方式(如先序、中序、后序或层次等)进行遍历，使其变为线索二叉树的过程称为对二叉树进行线索化。

线索链表：存储线索二叉树的链式结构

线索结点结构：`lchild+LTag+data+Rtag+rchild`

* 当`Tag`为0时，`lchild`和`rchild`表示其结点的左右孩子；当`Tag`为1时，`lchild`表示该结点在遍历中的**前驱结点**，`rchild`表示该结点在遍历中的**后继结点**

例如：对以下树进行中序线索化
![[Pasted image 20251102171150.png|301]]

步骤：

1. 写出中序遍历并在最前后结点补充NULL：`NULL→6→4→7→2→1→5→3→NULL`
2. 根据遍历得到中序线索二叉树，并得到线索链表：![[Pasted image 20251102171731.png]]

### 平衡二叉树



### 哈夫曼树(最优二叉树)

相关术语：

* 路径长度：从某个结点开始，在一条路径中，每经过一个结点，路径长度都要加 1 
* 结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权
* 结点的带权路径长度：指的是从根结点到该结点之间的路径长度与该结点的权的乘积
* 树的带权路径长度：为树中所有叶子结点的带权路径长度之和。通常记作 “WPL”。例如：下图树的带权路径长度为：$WPL=7*1+5*2+2*3+4*3$

![[Pasted image 20251031231952.png|212]]

定义：当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”（构成的树不唯一）

构建哈夫曼树的过程：对于给定的有各自权值的 n 个结点，每次选择其中两个最小结点构成兄弟结点，并创建新的父结点，权值为该两兄弟结点的权值和，然后删除两兄弟结点权值加入父结点权值重新选择，依次循环直至0

例：给定了五个结点A、B、C、D、E，权值分别为5,6,2,9,7
![[Pasted image 20251102174213.png]]

n个结点构成的哈夫曼树特点：

* 每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大
* 构造过程中共新建了 n-1个结点，因此哈夫曼树的结点总数为2n-1（总为奇数）
* 每次构造都选择2棵树作为新结点的孩子，因此哈夫曼树中不存在度为1的结点。
	* $n_{哈总}=n_0+n_2$，又$n_0=n_2+1$，故已知一棵哈夫曼树结点数，即可求度为0、2的结点数

==哈夫曼编码==

在数据通信中，若对每个字符用相等长度的二进制位表示,称这种编码方式为**固定长度编码**。若允许对不同字符用不等长的二进制位表示，则这种编码方式称为**可变长度编码**。可变长度编码比固定长度编码要好得多，其特点是对频率高的字符赋以短编码，而对频率较低的字符则赋以较长一些的编码，从而可以使字符的平均编码长度减短，起到压缩数据的效果。哈夫曼编码是一种被广泛应用而且非常有效的数据压缩编码。（了解）

前缀编码：若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码，哈夫曼编码一定是前缀编码。例如：设计字符 A,B和C对应的编码 0,101和100，则它们是前缀编码。但如果设计00和001，则001不是前缀编码。

* 解码：对前缀编码的解码很简单，因为没有一个编码是其他编码的前缀。所以识别出第一个编码，将它翻译为原码，再对余下的编码文件重复同样的解码操作。例如，码串 00101100 可被唯一地翻译为 0,0,101和 100。

图形表示：在二叉树中，每一个哈夫曼编码都对应一个叶子结点，从根节点开始，向左走表示0，右走表示1，拼接根节点到叶子结点的数字即为该叶子结点的对应哈夫曼编码。例如：下图中，字符a、b、e的对应编码为0、101、1101

![[Pasted image 20251102152916.png|494]]

哈夫曼编码判断：

* 数角度：看所有构成的编码中，是否存在某编码为另一编码的前缀，存在则不是，反之则是
* 图角度：画出所有编码构成的二叉树，如果该编码都对应叶子结点，则为哈夫曼编码，否则不是

# 串、数组(矩阵)、广义表

## 串

定义：串(string)是由零个或多个字符组成的有限序列。一般记为 S='a_1a_2....a_n'(n>0)。其中，S 是串名，单引号括起来的字符序列是串的值。a_i可以是字母、数字或其他字符，串中字符的个数n称为串的长度。n=0 时的串称为**空串**(用∅表示)。

* 空格串：由空格组成的串，长度为空格数，空格串不是空串

子串与主串(考)：串中任意多个连续的字符组成的子序列称为该串的子串，空串是任何串的子串，串本身也是自己的子串。包含子串的串称为主串。

位置(考)：某个字符在串中的序号称为该字符在串中的位置。子串在主串中的位置以子串的第一个字符在主串中的位置来表示。

串相等(考)：当两个串的长度相等且每个对应位置的字符都相等时，称这两个串是相等的。

长度为n的串，求子串个数(考)：

* 子串个数：$\frac{n(n+1)}{2}+1$
* 非空子串：$\frac{n(n+1)}{2}$
* 真子串：$\frac{n(n+1)}{2}$
* 非空真子串：$\frac{n(n+1)}{2}-1$

串有两种基本存储为顺序存储和链式存储

定长顺序存储表示：类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。

变长分配存储表示：堆分配存储表示仍然以一组地址连续的存储单元存放串值的字符序列，但它们的存储空间是在程序执行过程中动态分配得到的。

存储与操作：串的逻辑结构和线性表极为相似，区别仅在于串的数据对象限定为字符集。在基本操作上，串和线性表有很大差别：线性表的基本操作主要以**单个元素**作为操作对象，如查找、插入或册除某个元素等。而串的基本操作通常以**子串**作为操作对象，如查找、插入或删除一个子串等(不同)。

串的基本操作：

- StrAssign(&T, chars)：赋值操作，把串 T 赋值为 chars
- StrCopy(&T, S)：复制操作，由串 S 复制得到串 T
- StrEmpty(S)：判空操作，若 S 为空串，则返回 TRUE，否则返回 FALSE
- StrCompare(S, T)：比较操作，若 S > T，则返回值 > 0；若 S = T，则返回值 = 0；若 S < T，则返回值 < 0
- StrLength(S)：求串长，返回串 S 的元素个数
- Substring(&Sub, S, pos, len)：求子串，用 Sub 返回串 S 的第 pos 个字符(0开始)起长度为 len 的子串
- Concat(&T, S1, S2)：串联接，用 T 返回由 S1 和 S2 联接而成的新串
- Index(S, T)：定位操作，若主串 S 中存在与串 T 值相同的子串，则返回它在主串 S 中第一次出现的位置；否则函数值为 0
- ClearString(&S)：清空操作，将 S 清为空串
- DestroyString(&S)：销毁串，将串 S 销毁

==串的模式匹配==

含义：子串的定位操作通常称为串的模式匹配，它求的是子串(常称**模式串**)在主串中的位置

**简单模式匹配算法**：在主串S中，从左到右逐个字符与模式串P比较，若失配，则主串从下一个字符重新开始比较，直到匹配成功或全部失败。

![[Pasted image 20251108154214.png|436]]

简单的模式匹配算法的最坏时间复杂度为O(nm)，其中n和m分别为主串和模式串的长度。

**KMP算法**

KMP 算法的特点就是：仅仅后移模式串，比较指针不回。

字符串的前缀、后缀和最大公共前后缀长度(考)：

* 前缀：指除最后一个字符以外，字符串的所有头部子串
* 后缀：指除第一个字符外，字符串的所有尾部子串
* 最大公共前后缀长度：前缀与后缀中相同的最长部分的长度
* 串的最大公共前后缀长度：所有前缀子串的最大公共前后缀长度的结果形成的数组

例子：'ababa' 

* ′a′的前缀和后缀都为空集，最大公共前后缀长度长度为0。
* ′ab′的前缀为{a}，后缀为{b} , {a} ∩ {b} = NULL，最大公共前后缀长度长度为0。
* 'aba'的前缀为{a,ab}，后缀为{a,ba} , {a,ab} ∩ {a,ba} = {a}，最大公共前后缀长度长度为1
* 'abab'，前缀∩后缀，{a,ab,aba} ∩ {b,ab,bab} = {ab}，最大公共前后缀长度长度为2。
* 'ababa'，前缀∩后缀，{a,ab,aba,abab} ∩ {a,ba,aba,baba} = {a,aba}，公共元素有两个，最大公共前后缀长度长度为3
* 所以字符串'ababa'的最大公共前后缀长度为00123

从而得到最大公共前后缀长度(Partial match,PM)的表：

| 编号  | 1   | 2   | 3   | 4   | 5   |
| --- | --- | --- | --- | --- | --- |
| S   | a   | b   | a   | b   | a   |
| PM  | 0   | 0   | 1   | 2   | 3   |

将PM表的PM行右移一位，就得到了next数组：

| 编号   | 1   | 2   | 3   | 4   | 5   |
| ---- | --- | --- | --- | --- | --- |
| S    | a   | b   | a   | b   | a   |
| next | -1  | 0   | 0   | 1   | 2   |

有时为了使公式更加简洁、计算简单，将 next 数组整体+1。因此，next 数组就变成：

| 编号   | 1   | 2   | 3   | 4   | 5   |
| ---- | --- | --- | --- | --- | --- |
| S    | a   | b   | a   | b   | a   |
| next | 0   | 1   | 1   | 2   | 3   |

## 数组

### 数组的存储

==一维数组==

数组表示：`A[O,n-1]`表示数组从下标O开始到n-1

基地址：数组的第一个元素的地址

内存地址定位函数：$LOC(a_i,a_j)$或$LOC(i,j)$或$LOC[i,j]$

已知数组的开始存储地址$LOC(0)$，每个元素占用n个字节，则第`[i]`个元素的开始存储地址为$LOC(i)=LOC(0)+(i-0)*n$

==二维数组==

存储：按顺序存储结构有两种存储方式：按行优先存储(平常)或按列优先存储

已知$A[i_1​][j_1​]$的地址求$A[i_2][j_2]$地址公式：

* 按行存储：$LOC(i_2,j_2)=LOC(i_1,j_1)+[(i_2-i_1)*列宽+(j_2-j_1)]*字节$
* 按列存储：$LOC(i_2,j_2)=LOC(i_1,j_1)+[(j_2-j_1)*行宽+(i_2-i_1)]*字节$

已知数组下标从S开始，分别求数组按行存储和按列存储时元素A\[i]\[j]的位置：

* 按行存储：$(i−S)×列宽+(j−S)+1$
* 按列存储：$(j−S)×行宽+(i−S)+1$

题型：某个元素按行存储下标，求改为按列存储时的下标

* 思路：利用该元素偏移量相等

例：已知M\[0...8]\[1...10]，按行优先存储时，元素M\[8]\[5]的地址为ar，则按列优先存储时，地址ar存储的数组元素应是(M\[3]\[10])

* 解析：设列存储时为M\[i]\[j]，则 $(8-0)*10+(5-1)+1=(j-1)*9+(i-0)+1$

### 矩阵

压缩矩阵：指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。其目的是节省存储空间。

特殊矩阵：指具有许多相同矩阵元素或零元素,并且这些相同矩阵元素或零元素的分布有一定规律性的矩阵。常见的特殊矩阵有对称矩阵、上(下)三角矩阵、对角矩阵等。

特殊矩阵的压缩存储方法：找出特殊矩阵中值相同的矩阵元素的分布规律，把那些呈现规律性分布的、值相同的多个矩阵元素压缩存储到一个存储空间中。

==矩阵的压缩存储==

**对称矩阵**：若对一个n阶方阵 $A[1...n][1...n]$中的任意一个元素$a_{i,j}$,都有 $a_{i,j}=a_{j,i}$，则称其为对称矩阵。对于一个n阶方阵，其中的元素可以划分为3个部分，i<j为上三角区、i=j为主对角线，i>j为下三角区。

对称矩阵的存储：对于n阶对称矩阵，上三角区的所有元素和下三角区的对应元素相同，若仍采用二维数组存放，则会浪费几乎一半的空间，为此将对称矩阵 $A[1...n][1...n]$存放在一维数组 $B[\frac{n(n+1)}{2}]$中，元素 $a_{i,j}$,存放在 $B_k$中。只存放一三角部分和主对角部分的元素。

数组下标从0开始的，二维矩阵从1开始，按行存储，存储在下三角和主对角线部分，对称矩阵元素所在$B_k$数组中下标k值是：$$k=\begin{cases}\frac{i(i-1)}{2}+j-1&,i\geq j(下三角区和主对角线)\\\frac{j(j-1)}{2}+i-1&,i<j(上三角区)\end{cases}$$

* 当从$[0][0]$开始时，则将其中的i和j替换为i+1和j+1
* 其余情况画图

**三角矩阵**：当上三角区的所有元素均为同一常量时，为下三角矩阵，此时存储完下三角区和主对角线的元素后，存储一次上三角区常量一次。上三角矩阵相反

**稀疏矩阵**：矩阵中非零元素的个数t，相对矩阵元素的个数s来说非常少，即称为稀疏矩阵。例如个矩阵的阶为 100x100，该矩阵中只有少于 100 个非零元素。

稀疏矩阵的存储(**考**)：将非零元素及其相应的行和列构成一个三元组(行标，列标，值)。例如下例![[Pasted image 20251105222154.png]]

## 广义表

广义表（Generalized List）是一种线性表的扩展，是由零个或多个元素组成的有限序列，其中每个元素既可以是原子，也可以是另一个广义表

* 表头（Head）：第 1 个元素(一个数或表)
* 表尾（Tail）：去掉第一元素后的(所有)广义表。
* Head(表)和Tail(表)求表头和表尾(**考**)，会互相嵌套。例：已知广义表A=(a,b,(c,d))，求Tail(Tail(A))=(c,d)
* 判断：它是线性表的推广和扩展，属于递归的非线性结构；广义表的元素可以是广义表；广义表是一种多层次的结构；广义表是一种共享结构

广义表的深度和长度(**考**)：

* 长度：为表中最外层元素的个数
* 深度：为表中括号的最大层数(最大括号数)
* 例：已知B=(d, e)和C=(b,(c, d))，则D=(B,C)的长度位2，深度为3
* 例：E=(a,E)是一个长度为2，无限深的广义表

广义表画图(树)：每一结点为一元素，原子为方块，子表为圆，从外画到内。例如：A=(B,y)，B=(x,L)，L=(a,b)

![[Pasted image 20251108174633.png|294]]

已知广义表的图，求表示：((e),(),(a,(b,c,d)),(b,c,d))

![[Pasted image 20251108174310.png]]

# 图

## 概念

图(Graph)是由顶点的有穷非空集合和**顶点**之间边的集合组成，通常表示为：G=(V,E)。
其中，G 表示一个图，V 是图G中的**顶点集合**，使用V={点1,点2,...}表示，E 是图G中的**边集合**，使用E={(点1,点2,),(点2,点3)...}表示

在图中需要注意的是：

* (1)线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点(Vertex)。
* (2)线性表可以没有元素，称为空表；树中可以没有结点，称为空树；但是，在图中不允许没有顶点(有穷非空性)。
* (3)线性表中的各元素是线性关系，树中的各元素是层次关系，而图中各顶点的关系是用边来表示(边集可以为空)。

术语：

* 无向图：图中任意两个顶点之间的边都是无向边，最少边为0，最多边为无向完全图
* 有向图：图中任意两个顶点之间的边都是有向边，最少边为0，最多边为有向完全图
* 边的表示：无向图中，边表示为(Vᵢ,Vⱼ)
* 弧：在有向图中，通常将边称为弧，含箭头的一端称为弧头，另一端称为弧尾，记作<Vᵢ,Vⱼ>，它表示从顶点Vᵢ到顶点Vⱼ的一条边(尾到头)。
* 无向完全图：在无向图中，如果任意两个顶点之间都存在边(边最多)，则称该图为无向完全图。含有n个顶点的无向完全图有n(n-1)/2 条边。
* 有向完全图：在有向图中，弧数最少为0，如果任意两个顶点之间都存在方向互为相反的两条弧(弧最多)，则称该图为有向完全图。
* 稠密图与稀疏图：当一个图接近完全图时，则称它为稠密图(Dense Graph)，e≥nlog₂n，e为边数，n为顶点数。当一个图含有较少的边时，则称它为稀疏图(Spare Graph)，e≤nlog₂n。
* 顶点的度：顶点V的度(Degree)是指在图中与V相关联的边的条数。
	* 对于有向图来说，有入度(Imn-degree)和出度(Out-degree)之分，有向图顶点的度等于该顶点的入度和出度之和，各顶点的入度之和等于各顶点的出度之和，所有顶点的度和等于边数×2。
	* 对于无向图来说，只有度，所有顶点的度和等于边数×2。
* 邻接：若无向图中的两个顶点V₁和V₂存在一条边(V₁,V₂)，则称顶点V₁,和V₂邻接(Adjacent),也可以称顶点V₁和顶点V₂互为邻接点。若有向图中的两个顶点V₁和V₂存在一条弧<V₁,V₂>,则称顶点V₁邻接到顶点V₂，或顶点V₂邻接自顶点V₁。
* 路径：在无向图中，若从顶点Vᵢ出发有一组边可到达顶点Vⱼ，则称顶点Vᵢ到顶点Vⱼ的顶点序列为从顶点Vᵢ到顶点Vⱼ的路径(Path)。例如以下无向图中顶点A到顶点B就有两条路径，分别是：A→B和A→C→B
* 回路(环)：若一条路径中第一个顶点和最后一个顶点相同，则这条路径是一条回路。
* 连通、连通分量、连通图：
	* 连通：在无向图中，若从Vᵢ到Vⱼ有路径可通，则称顶点Vᵢ和顶点Vⱼ是连通(Connected)的
	* 连通分量：在无向图中，子图中任意两个顶点之间都有路径相连，则每个子图都为一个连通分量。一个极大的连通子图称为连通分量。单个顶点也是一个连通分量。如下图中，有{A,B,C,D}和{E,F}两个连通分量
	* 连通图：无向图中任意两个顶点之间都连通(任意两点存在路径)。连通图只有一个连通分量为本身
* 强连通、强连通分量、强连通图：
	* 强连通：在有向图中，若从Vᵢ到Vⱼ和从Vⱼ到Vᵢ有路径可通，则称顶点Vᵢ和顶点Vⱼ是强连通的
	* 强连通分量：在有向图中，子图中任意两个顶点之间都有路径相连，则每个子图都为一个强连通分量。一个极大的强连通子图称为强连通分量。单个顶点也是一个强连通分量。
	* 强连通图：有向图中任意两个顶点之间都强连通。强连通图只有一个强连通分量为本身
* 权和网(带权图)：图的边或弧具有与它相关的数字，则这个数字叫做权。带有权的图称带权图，也叫网

![[Pasted image 20251109102410.png|608]]

![[Pasted image 20251109103933.png|334]]

生成树和生成森林：

* 若一个无向图有n个顶点，边数少于n-1，则该图不是连通图。边数大于 n-1，该图必有环。要连通具有n个顶点的有向图，至少需要n条边
* 生成树：在无向连通图中，生成树包含图中所有的顶点，任意两点之间仅有一条通路，只有连通图才能生成树，非连通图没有。生成树满足边数=顶点数-1的连通无环图
* 最小生成树：最小生成树是在带权的连通无向图中，  所有生成树中边权和最小的一棵。
* 生成森林：对应非连通图，每个连通分量为对应一个生成树，多个生成树组成生成森林

例：以下连通图生成树![[Pasted image 20251112143539.png]]

* 说明：生成树不唯一

## 图的存储

==邻接矩阵==

邻接矩阵法：图的领接矩阵(Adiacency Matrix)存储是用一个**一维数组**存储图中**顶点**的信息和一个**二维数组**(称为邻接矩阵)存储图中的**边或弧**的信息，邻接矩阵的表示唯一。（顺序存储）

无向图的邻接矩阵：![[Pasted image 20251109154951.png]]

* 特点：
	* 第i行或第i列的非零元素个数正好是第i个顶点的度。
	* 无向图的领接矩阵一定是对称的(区别于有向图的邻接矩阵)。
	* 故n个顶点，e条边的无向图，采用邻接矩阵存储，则矩阵中零元素的个数为 n² -2e（总元素数-已有边数）。
* 结果：只要邻接矩阵的括号和其中数字

有向图的邻接矩阵：![[Pasted image 20251109155246.png]]

* 特点：
	* 第i行的非零元素个数正好是第i个顶点的出度，第i列的非零元素个数正好是第i个顶点的入度。
	* 故n个顶点，e条边的无向图，采用邻接矩阵存储，则矩阵中零元素的个数为 n² -e

网的邻接矩阵：![[Pasted image 20251109155822.png]]

* 说明：邻接矩阵的∞也可以用0表示，具体请以题目为准，若没有提示，默认用∞表示。

空间复杂度：邻接矩阵的大小和顶点数有关，若顶点数为n，其空间复杂度为 O(n²)。故存储稠密图时适合用邻接矩阵

==邻接表==

图的链式存储结构有邻接表、十字链表和邻接多重表三种

含义：所谓邻接表就是对图中的每个顶点建立一个单链表，每个单链表的第一个结点存放有关顶点的信息，把这一结点看作链表的表头(也称为**表头结点表**)，其余结点(**边表**)存放有关边的信息，邻接表的表示不唯一。

无向图的邻接表：![[Pasted image 20251109165303.png]]

* 说明：当前结点为表头，其余结点为该结点所邻接的结点，一般从小排到大
* 顶点V的度恰好等于该顶点的领接表中边结点的个数

有向图的邻接表和逆邻接表：![[Pasted image 20251109171914.png]]

* 说明：邻接表表示顶点的出度的连接，逆邻接表表示顶点的入度的连接
* 邻接表中顶点V的领接表中边结点的个数仅为该顶点的出度；逆邻接表中顶点V的领接表中边结点的个数仅为该顶点的入度

网的邻接表：![[Pasted image 20251109172210.png]]

* 说明：每个边结点有两个值，表示该顶点和边的权

空间复杂度：

* 对于有n个顶点和e条边的无向图，其邻接表有n个顶点结点和 2e个边结点，为O(2n+e)
* 对于有n个顶点和e条弧的有向图，其邻接表有n个顶点结点和e个弧结点，为O(n+e)
* 显然，对于稀疏图，邻接接表比邻接矩阵节省存储空间

==十字链表法==

## 遍历

对有向图进行遍历时需要根据出度进行遍历，对网进行遍历时忽略权

==深度优先遍历（深度优先搜索(Depth First Search)）==

图的深度(优先)遍历（DFS算法）：首先访问出发点v，并将其标记为已访问过，然后选取与v邻接的未被访问的任意一个顶点w并访问它，再选取与w邻接的未被访问的任一项点并访问，以此重复进行。当一个顶点所有的邻接顶点都被访问过时，则依次退回到最近被访问过的顶点，直到所有结点遍历完

* DFS是递归算法，需要借助一个**递归工作栈**，故其空间复杂为 O(|V|)（V为树或图的顶点数。
* 图的深度优先遍历类似二叉树的先序遍历

例：从结点A对无向图开始遍历![[Pasted image 20251109174709.png]]

* 遍历结果：A,D,E,C,B
* 理解：根根边
* 说明：对于同一个图，其深度优先遍历的结果可能不唯一

例：从结点1开始对无向图的邻接表进行遍历![[Pasted image 20251112173207.png]]

* 遍历结果：1,2,3,4,5,6
* 遍历说明：对边结点进行遍历时，转移到以该结点为表头的链表中进行遍历，并且必须按边表的结点顺序进行遍历，不能跳跃

深度优先遍历耗费的时间则取决于所采用的存储结构。当用邻接矩阵作图的存储结构时，查找每个顶点的邻接点所需时间为 O(n²)，其中n为图中顶点数。而当以邻接表作图的存储结构时，找邻接点所需时间为 O(e)，其中e为无向图中边的数或有向图中弧的数。

由此，当以邻接表(无向或有向图)作存储结构时，DFS的时间复杂度为O(n+e)(访问每个顶点一次+遍历每个顶点的邻接边)；以邻接矩阵作存储结构时，DFS的时间复杂度为O(n^2) 。

==广度优先遍历（广度优先搜索(Breadth First Search)）==

图的广度优先遍历（BFS算法）：先访问完当前顶点的所有邻接点，再遍历其邻接结点，对邻接结点进行相同遍历，直到所有结点都遍历完

* BFS借助**队列**实现
* 图的广度优先遍历类似于树的层次遍历

例：从V₀开始遍历有向图![[Pasted image 20251109182406.png]]

* 遍历结果：V₀,V₁,V₂,V₃,V₄
* 理解：根边边
* 说明：在遍历时，没有出度指向V₄，作为最后遍历
* 对于同一个图，其广度优先遍历的结果可能不唯一

例：从结点1开始对无向图的邻接表进行遍历![[Pasted image 20251112173207.png]]

* 遍历结果：1,2,4,3,5,6
* 遍历说明：从上到下每一行进行遍历，遍历要按照边表中顶点的顺序进行

时间复杂度：用邻接表时BFS=O(n + e)；用邻接矩阵时BFS=O(n^2)

* 总结：时间复杂度只与邻接矩阵或邻接表有关，与什么遍历方式无关

遍历生成树：将遍历过程的顶点和边保留，删除多余边即画出

## 应用

### 生成最小生成树

最小生成树：从一个带权无向连通图中选取一些边，使得所有顶点都被连接（也就是形成一棵树），不存在环，所有选中边的权值和最小

==Prim(普里姆)算法==

步骤：从已加入集合的顶点中，选择一条**权值最小的边**，连接一个未在集合中的顶点，加入该顶点，继续选边，直到所有顶点都加入为止

* 适合稠密网的最小生成树

网使用算法求最小生成树例子：从顶点0开始![[Pasted image 20251110202350.png|545]]

* 说明：上面图b也可以先把顶点2和顶点4相连，所以说最小生成树可能不唯一，但是代价(权和)还是相同的
* 结果：最后要消除权，所以边集用{(),()}表示
* 时间复杂度为O(n²)

==Kruskal(克鲁斯卡尔)算法==

步骤：将所有边按权值从小到大排序，从最小权值的边开始选，若加入该边后不形成环 → 选入生成树，重复步骤直到选出 n-1 条边（n = 顶点数）

* 适合稀疏网的最小生成树

网使用算法求最小生成树例子：![[Pasted image 20251110204427.png|555]]

* 说明：c和d可以互换顺序

### 生成最短路径

最短路径：在网图和非网图中，最短路径的含义是不同的。由于非网图它没有边上的权值，所谓的最短路径，其实就是指两顶点之间经过的边数最少的路径；而**对于网图来说，最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。**

Dijkstra(迪杰斯特拉)算法：用于求某个源点到其它各个顶点的最短路径

Floyd(弗洛伊德)算法：用于求图中每一对顶点间的最短路径

相关视频教学：

* 【图-最短路径-Dijkstra(迪杰斯特拉)算法-哔哩哔哩】 https://b23.tv/9m1Gtj6
* 【图-最短路径-Floyd(弗洛伊德)算法-哔哩哔哩】 https://b23.tv/NiEnj6k

### 拓扑排序

AOV网：用有向无环图表示活动及其先后关系的模型。顶点代表活动，有向边表示活动之间的先后顺序约束。

拓扑排序只适用于有向无环图，因此如果一个AOV网不能进行拓扑排序，则该网必定有环

步骤：删除入度为0的顶点并输出，并删除该顶点的出度边，直到删不动为止。若失败则有环。

例：对下图进行拓扑排序![[Pasted image 20251110225854.png]]

* 结果：12435
* 说明：可能某步有多个可删除的顶点，所以可能结果不唯一

### AOE网？

# 查找

概念：

* 查找：在数据集合中寻找满足某种条件的数据元素的过程称为查找。查找的结果一般分为两种：查找成功和查找失败。
* 查找表(查找结构)：用于查找的数据集合称为查找表，它由同一类型的数据元素(或记录)组成，可以是一个数组或链表等数据类型。对查找表经常进行的操作一般有4种：
	* ①查询某个特定的数据元素是否在查找表中
	* ②检索满足条件的某个特定的数据元素的各种属性
	* ③在查找表中插入一个数据元素
	* ④从查找表中删除某个数据元素
* 静态查找表：只涉及①和②，无需修改表中数据的表。查找方法有顺序查找、折半查找、散列查找
* 动态查找表：涉及③和④，需要动态的插入或删除的查找表称为动态查找表。查找方法有二叉排序树的查找、散列查找
* 查找长度(查找次数)：指的是在一次查找过程中，需要进行关键字比较的次数
* 平均查找长度(ASL)：在查找过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值。
* 关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。

## 查找方法

==顺序查找==：作为一种最直观的查找方法，其基本思想是从线性表的一端开始，逐个检査关键字是否满足给定的条件。

* 平均查找长度：若表中有n个元素，且查找概率都相等时，有$ASL_{成功}=(1/n)*n*(1+n)/2=(n+1)/2$，查找失败时，每个关键字都比较n次，则$ASL_{失败}=n$
* 优缺点：顺序查找的缺点是当n较大时，平均查找长度较大，效率低；优点是对数据元素的存储没有要求，顺序存储或链式存储皆可，对表中记录的有序性也没有要求，无论记录是否按关键字有序，均可应用。
* 注意：对线性的链表只能进行顺序查找。
* 有序表的顺序查找：若在查找之前就已经知道关键字是有序的，则查找失败时可以不用再比较到表的另一端就能返回查找失败的信息，从而降低顺序查找失败的平均查找长度。例：假设查找表为(1,2,3,7,8,10)排列，查找5时发现比7小时则直接返回查找失败

==折半查找(二分查找)==：折半查找的基本思想：首先将给定值key与表中中间位置的元素比较，若相等，则查找成功，返回该元素的存储位置；若不等，只能去中间元素以外的前半部分或后半部查找。然后在缩小的范围内继续进行同样的查找，如此重复，直到找到为止，或确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。

* 注意：折半查找只适用于有序的顺序表(顺序结构)
* 例子：在以下表中查找19

![[Pasted image 20251117223335.png|412]]
* 通过画判定树(类二叉排序树)查找：以第一次二分查找的值作为根结点，按左小右大画其余结点，从根结点开始，每次查找都是按照从上到下进行比较。
	* 性质：从上到下的层数即为二分查找时对应查找长度。查询在n个元素中某个结点的最多次数时为该判定树的最大层数
	* 平均查找长度：$ASL_{成功}=每一层结点个数*层数的总和/结点个数$，如下图为$(1*1+2*2+3*4+1*4)/8≈2.625$；对于失败查找，需要先补充二叉树使所有结点的度为2，其中称补充的结点为失败位置，则$ASL_{失败}=每一层失败位置结点个数*其父结点层数的总和/结点个数$，如下图为$(7*3+2*4)/9≈3.22$
	* ![[Pasted image 20251117225942.png]]
* 时间复杂度：时间复杂度为$O(log_2n)$

==分块查找(索引顺序查找)==：分块查找的基本思想：将查找表分为若干子块。块内的元素可以有序或无序但块之间是有序的，再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。是一种结合了顺序查找和折半查找的方法。

* 特点：查找较快，且插入和删除操作也比较方便
* 分块查找的过程分为两步：第一步是在索引表中确定待查记录所在的块，可以顺序查找或折半查找索引表；第二步是在块内顺序查找。例：在关键码集合为{88,24,72,61,21,6,32,11,8,31,22,83,78,54}，按照关键码值 24,54,78,88,分为4个块和索引表
* ![[Pasted image 20251117232956.png]]
* 平均查找长度：为索引查找和块内查找的平均查找长度之和。

## 散列表(哈希表)

概念：

* 散列(哈希)函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为 $Hash(key)=addr$(这里的地址可以是数组下标、索引或内存地址等)
* 冲突：散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为冲突，这些发生碰撞的不同关键字称为**同义词**。设计得好的散列函数应尽量减少这样的冲突
* 散列表：根据关键字而直接进行访问的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。
* 理想情况下，对散列表进行查找的时间复杂度为 O(1)，即与表中元素的个数无关

散列查找法：

散列函数构造方法：

* 保留余数法：假定散列表表长为m，取一个不大于m但最接近m的质数p，则$H(key)=key\%p$
	* 求表长：已知哈希地址空间为\[0...m\]，则散列表长为m+1；已知装填因子α=n，则散列表长为 查找表表长/n
* 注意点：
	* 散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围
	* 散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间中，从而减少冲突的发生
	* 散列函数应尽量简单，能够在较短的时间内计算出任一关键字对应的散列地址

处理冲突的方法：

* 开放定址法：使用该公式重新计算地址$H_i= (H(key) + d_i)\%m$（m为表长），各个关键字独立计算![[Pasted image 20251119223233.png]]
	* 线性探测法：$d_i$的值依次为1,2,3,...m-1（理解：每次结果为往后一位）
		* 缺点：发生二次聚集(堆积)现象：冲突时，两次冲突计算的两个地址在同一个位置后一直都向后做同位置探测，此时会影响平均查找长度
	* 二次探测法：$d_i$的值依次为$1^2,-1^2,2^2,-2^2,k^2,-k^2(k\leq m/2)$
* 链表法：将冲突的同义词放在由该地址为带头结点的链表中![[Pasted image 20251119223151.png|408]]

开放地址法的平均查找长度：

* 查找成功：为构建散列表时 $ASL_{成功}=所有关键字计算地址时的次数和/关键字个数$；
* 查找失败：当查找到在某个散列表地址时，如果该位置为空，则计为1次查找失败，如果该位置有关键字，并且后一位置的关键字也不是要查找的关键字则计1次，每当该位置有关键字时都往后一位找。$ASL_{失败}=所有地址位置开始查找的失败次数的和/散列表表长$

例子：

## 平衡二叉树(AVL)的构建

步骤：给定多个结点，以第一个结点为根结点，其余结点插入时按小的左走大的右走，每插入一次，则对当前插入的结点及其父结点到根结点进行检查，若以该结点的左右子树高度差(平衡因子)大于1，则选择该结点以及路上的最近的另外两个结点一起进行旋转，旋转后对所有影响到的结点进行重新插入

* 失去平衡的四种情况及对应调整：![[Pasted image 20251120005456.png]]
* 理解：其实就是对这三个结点进行左中右大小排序；
* 记忆：在这三个结点中，对最高的结点依次判断另一个结点对于其父结点的位置(L左或R右)

例子：依次插入100，90，80，60，70，50，120，110，150，87。![[Pasted image 20251120005900.png]]![[Pasted image 20251120005909.png]]![[Pasted image 20251120005916.png|663]]
# 排序

排序方法的稳定性：如果排序后，原来相等的两个元素的相对先后顺序不发生改变，则该排序算法是稳定的；否则是不稳定的。

内部排序：指在计算机内存中进行的排序

外部排序：在排序的过程中需要借助外存的排序过程

内部排序是指待排序记录全部存放在计算机内存中进行排序，不需要访问外存，适照于排序记录较少的情况；外部排序是指待排序记录的数量很大，内存无法容纳全部数据，在排序的过程中心要借助外存的排序。

## 插入排序

### 直接插入排序

基本思想：插入排序的基本思想为每步将一个待排序的对象，按其关键码大小，插入到前面已经排好序的一组对象的适当位置上，直到对象全部插入为止。即**边插入边排序，保证子序列中随时都是排好序的**。（稳定）

* 适用性(了解)：适用于顺序存储和链式存储的线性表

例子：对序列(13,6,3,31,9,27,5,11)进行增序排列

* ①将元素 13 作为第一个记录，此时有序表为(13)。将元素 13 与元素6比较，13>6，插入至元素 13 前，此时有序表为(6,13)
* ②元素3与元素13 比较，再与元素6比较，均小于，插入到6之前，此时有序表为(3,6,13)。
* ③以此循环，直至最后成为一个有序序列。

例子：已知待排序记录的关键字序列为(35,21,69,45,86,58,14,36,49,10),请给出使用直接插入排序的排序过程。(递增排序)![[Pasted image 20251129155741.png|642]]

空间复杂度：仅使用了常数个辅助单元，为O(1)

时间复杂度：在排序过程中，向有序子表中逐个地插入元素的操作进行了 n-1趟，每趟操作都进行了比较关键字或移动元素，所以**直接插入排序的时间复杂度与待排序表的初始状态有关**

* 最好情况：表中元素已经有序，此时每插入一个元素，都只需比较一次而不用移动元素，因而时间复杂度为 O(n)。
* 最坏情况：表中元素顺序刚好与排序结果中的元素顺序相反(逆序)，总的比较次数达到最大，为O(n²)
* 平均情况：O(n²)

### 希尔排序

基本思想：是插入排序的一种改进版本，通过将待排序序列划分为若干个子序列，分别进行插入排序，最终合并成有序序列，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。(不稳定)

* 子序列的选择：子序列的构成不是简单地“逐段分割”将相隔某个增量dₖ的记录组成一个子序列，让增量dₖ=值**逐趟缩短**(例如依次取 5,3,1)，直到dₖ=1为止（题目会给）
* 适用性：仅适用于顺序存储
* 希尔排序的组内排序采用的是直接插入排序

例子：对关键字序列 T=(49,38,65,97,76,13,27,49*,55,04)，按照增量d₁=5、d₂=3、d₃=1，进行关键字递增排序

* 第一趟取增量d₁=5，49、13和38、27和65、49\*和97、55和76、04共五组，排序结果如下
* 第二趟取增量d₂=3，13、55、38、76和27、04、65和49\*、49、97共三组，排序结果如下
* 第三趟取增量d₃=1，全部为一组，排序结果如下
* ![[Pasted image 20251123080554.png]]

例子：已知待排序记录的关键字序列为(36,78,12,52,34,2,96,53,22,84)，请给出使用希尔排序的排序过程。(增量取5、3、1)![[Pasted image 20251129154826.png]]

空间复杂度：仅使用了常数个辅助单元，为O(1)

时间复杂度：由于希尔排序的时间复杂度依赖于增量序列的函数，这涉及数学上尚未解决的难题，所以其时间复杂度分析比较困难。当n在某个特定范围时，希尔排序的时间复杂度约为$O(n^{1.3})$。在最坏情况下希尔排序的时间复杂度为$O(n^2)$。

* 希尔排序的时间复杂度与增量序列的选择有关，而与待排序表的初始状态无关

## 交换排序

### 冒泡排序

基本思想：通过多趟比较相邻元素，让较大的（或较小的）元素一步步“冒”到序列的一端，直到整个序列有序（稳定）

例子：对关键字序列 T=(21，25，49，25*，16，08)，进行关键字递增排序如下：![[Pasted image 20251123162218.png]]

* 规律：n个数会比较n-1趟，第i趟会比较n-i次

例子：已知待排序记录的关键字序列为(49,15,96,78,84,36,12,58,45,61)，请给出使用冒泡排序的排序过程。(递增排序)![[Pasted image 20251129155813.png]]

空间复杂度：仅使用了常数个辅助单元，为 O(1)

时间复杂度：冒泡排序的时间复杂度与待排序表的初始状态有关

* 最好情况：待排序表已经有序，只需1趟排序，比较次数为n-1，为$O(n)$
* 最坏情况：待排序表逆序，需n-1趟排序，第i趟比较n-i次，为
* 平均情况：$O(n^2)$

注意：冒泡排序中所产生的有序子序列一定是全局有序的(不同于直接插入排序)，也就是说，有序子序列中的所有元素的关键字一定小于或大于无序子序列中所有元素的关键字，这样每趟排序都会将一个元素放置到其最终的位置上。

### 快速排序

过程（不稳定）：

* 从序列中选择一个“枢轴”，将该位置凿空
	* 枢轴的选取：第一趟通常选第一个，然后分两边为界，如果一分区有多个元素，则再以该分区的首个元素为枢轴
- 设置左右指针：左指针从凿空处开始，右指针从分区的右端开始
- 右指针开始左移动，直到遇到一个小于枢轴的元素为止，将该元素放到凿空处，右指针处变为凿空；改为左指针往右移动，直到遇到一个大于枢轴的元素为止，将该元素放到凿空处，改另一边移动
- 当两个指针都指向凿空处时，将枢轴放到该位置，完成第一趟排序
- 再次选取枢轴，完成第二趟排序
- 理解：两指针左凿空右边端，有值的与枢轴比较，比较不符合则交换凿空和值，走另一边，直到两指针都走到凿空，则将枢轴填入完成一趟排序

例子：已知待排序记录的关键字序列为(30,90,15,85,63,47,45,52,87,10)，请给出使用快速排序的排序过程。(递增排序)![[Pasted image 20251129153554.png]]

空间复杂度：由于快速排序是递归的，最好情况下为$O(\log_2{n})$；最坏情况下为$O(n)$；平均情下，栈的深度为$O(\log_2{n})$

时间复杂度：快速排序是对冒泡排序的改进，当待排序列基本有序或有序时，其将会蜕化成
冒泡排序，时间复杂为$O(n^2)$。当每次划分都非常平均时，此时为最好情况，时间复杂度为$O(n\log_2{n})$。平均时间复杂度为$O(n\log_2{n})$（越乱越好）

快速排序是所有内部排序算法中平均性能最优的排序算法

## 选择排序

### 简单选择排序

步骤（不稳定）：

* 在未排序区间中找到最小(或最大)元素  
- 将找到的最小元素与未排序区间的第一个元素交换(从前往后排)
- 缩小未排序区间，继续寻找下一趟最小值  
- 重复n−1趟，整个序列即可有序

例子：已知待排序记录的关键字序列为(78,85,96,42,10,12,15,63,98,30)，请给出使用简单选择排序的排序过程。(递增排序)![[Pasted image 20251129154408.png|648]]

空间复杂度：仅使用常数个辅助单元，为 O(1)

时间复杂度：在简单选择排序过程中，元素移动的操作次数很少，最好的情况是移动0次，此时对应的表已经有序；但元素间比较的次数与序列的初始状态无关始终是 n(n-1)/2 次，因此时间复杂度始终是$O(n^2)$。

### 堆排序

大根堆与小根堆：在完全二叉树中，如果父结点都大于子结点，那么称为大根堆；如果父结点都小于子结点，则称为小根堆。当不满足大或小根堆时，此时不是堆

步骤（不稳定）：

* 初始化大根堆：将各关键字按照层次遍历构成完全二叉树，再按大小交换根与其子结点
* 输出根结点(最大值)，删除叶子结点到根结点，重新排序为大根堆
* 循环步骤2至所有结点都输出，输出时如果是从后往前排则为升序，反之为降序

堆排序适合关键字较多的情况。例如，在100万个数中选出前10个最大值

例子：

空间复杂度：仅使用了常数个辅助单元，为 O(1)

时间复杂度：建堆时间为 O(n)，之后有n-1次向下调整操作，每次调整的时间复杂度为O(h)，故在最好、最坏和平均情况下，堆排序的时间复杂度为$O(n\log_2n)$，不受待排序列初始状态的影响。相比较快速排序最大的优点是堆排序更省空间。

## 归并排序

==归并排序==

归并排序又称2路归并排序

基本思路：假设初始序列含有n个记录，则可看成是n个有序的子序列，每个子序列的长度为1，然后两两归并，得到n/2个长度为2或1的有序子序列：再两两归并，……，如此重复，直至得到一个长度为n的有序序列为止（稳定）

例子：对关键字序列 T=(49，38，65，97，76，13，27)，按照递增顺序，进行归并排序

* 第一趟：\[38 49\] \[65 97\] \[13 76\] \[27\]
* 第二趟：\[38 49 65 97\]与\[13 27 76\]，其中65和38、49比较完确定位置，比较2 次。由于97>65，因此97无需和38、49比较
* 第三趟：\[13 27 38 49 65 76 97\]

空间复杂度：辅助空间为n个单元，所以算法的空间复杂度为O(n)。

时间复杂度：每趟归并的时间复杂度为O(n)，共需进行$\lceil\log_2n\rceil$趟归并，所以算法的时间复
杂度为$O(n\log_2n)$。


## 总结

![[Pasted image 20251123224226.png]]

* 最好情况与最好情况相同时则该排序与待排序表的初始状态无关，反之则有关

空间复杂度：特计快速排序为$O(\log_2n)$和归并排序为$O(n)$（最差），其余为O(1)

时间复杂度：除快速排序和堆排序的时间复杂度为$O(n\log_2n)$外，其余都为$O(n^2)$

稳定性：除直接插入排序、冒泡排序稳定外，其余都不稳定

与初始状态关系：除所有选择排序和归并排序都无关外，其余都有关，一旦有关，则该方法的最坏情况为$O(n^2)$

解题步骤：写出初始序列，然后写每一趟，每次确定的元素区间使用()扩出来



