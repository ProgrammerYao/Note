# C简介和二进制转换

## C语言的特点

1. C语言**简洁、紧凑**，压缩了一切不必要的成份
2. C语言**运算丰富**，将括号、赋值、强制类型转换、取变量地址等都以运算实现
3. C语言**数据类型丰富**，具有现代语言的各种数据类型；用户能扩充数据类型，能够实现各种复杂的数据结构，完成各种问题的数据描述
4. C语言是一种**结构化程序设计语言**，具有结构化语言所要求的三种基本结构(顺序、选择 循环)
5. C语言是高级语言中的低级语言。C语言**允许直接访问物理地址**，能进行位运算，能实现汇编语言的大部分功能，能直接对硬件进行操作
6. C语言提供**编译预处理机制**，有利于大程序的编写和调试
7. C语言编译系统小，生成的目标代码质量高，程序的**执行效率高**
8. C语言的**输入和输出功能用库函数实现**，编写的程序**移植性好**
9. C语言语法限制不太严格，程序设计自由度大，对程序员要求较高

## 程序设计语言

### 概述

程序 = 算法 + 数据结构

算法：可以看作是由**有限个步骤组成的用来解决问题的具体过程**，算法有三种基本结构，分别是**顺序结构、选择结构和循环结构**

数据结构：是从问题中抽象出来的数据之间的关系，它代表信息的一种组织方式。反映一个数据的内部结构，其目的是提高算法的效率，它通常与一组算法的集合相对应，通过这组算法集合可以对数据结构中的数据进行某种操作。典型的数据结构包括线性表、堆栈和队列

计算机语言分类：机器语言、汇编语言、高级语言

机器语言是**机器能直接识别的程序语言或指令代码**，它直接由**0或1**这样的二进制数值进行编码。从系统结构的角度看，它是系统程序员看到的计算机的主要属性。指令系统表征了计算机的基本功能同时也决定了机器所能被要求的能力，也决定了指令的格式和机器的结构。机器语言由于**可以被计算机直接识别并执行**，所以它的执行效率很高，但是因为它是基于计算机指令系统的程序语言，所以可移植性很差

汇编语言采用一定的**助记符**来代替机器语言中的指令和数据，又称为符号语言。汇编语言一定程度上克服了机器语言难读难改的缺点，同时保持了其编程质量高、所占存储空间小、运行速度快的优点。故在程序设计中，对实时性要求较高的地方，如过程控制等，仍经常采用汇编语言，该语言也依赖于机器，不同的计算机一般也有着不同的汇编语言

机器语言和汇编语言统称为低级语言

用高级语言编写的程序易学、易读、易修改、通用性好，**不依赖于机器**，但**机器不能对其编制的程序直接运行**，必须经过语言处理程序的翻译后才可以被机器接受。高级语言的种类繁多，如面向过程的Fortran、Pascal、**C**等，面向对象的C++、Java、Visual BASIC等

### 语言处理程序

针对不同的程序设计语言编写出的程序，它们有各自的翻译程序，互相不通用

==汇编程序==

汇编程序是将汇编语言编制的程序(源程序)翻译成机器语言程序(目标程序)的工具。将汇编语言源程序转换为等价的目标程序的过程称为汇编

==高级语言翻译程序==

高级语言翻译程序是将高级语言编写的源程序翻译成目标程序的工具。翻译程序有两种工作方式：解释方式和编译方式。相应的翻译工具也分别称为解释程序和编译程序

解释：解释程序对源程序是**一边翻译、一边执行，不产生目标程序**。解释程序对源程序进行逐句分析，若没有错误，将该语句翻译成一个或多个机器语言指令，然后立即执行这些指令;若当它解释时发现错误，会立即停止，报错并提醒用户更正代码。早期的BASIC语言采用解释方式

编译：将高级语言所编写的**源程序**翻译成等价的用机器语言表示的**目标程序**。源程序经过编译处理，会产生一个与源程序等价的目标程序，但目标程序还不能直接执行，通过**连接**程序将目标程序和有关的程序库组合成完整程序**后才可以执行**。最终产生的可执行程序可以脱离编译程序和源程序独立存在并反复使用，大多数高级语言都是采用编译方式

==C语言编译过程==

![[Pasted image 20240904185811.png]]

过程：-编辑->源程序(.c文本文件)-编译->目标文件(.obj二进制文件)-连接->可执行文件(.exe二进制文件)-执行->

**其中源程序，目标程序不能被计算机直接执行，只有可执行文件能够被直接执行**

## C程序结构和基本语法成份

==C程序结构==

```C
# include <stdio.h>

int main() //函数头
{
	
} //函数体

// 单行注释

/*
	多行注释
*/
```

函数：C语言程序由若干函数组成，**函数是C程序的基本单位**。必须有一个主函数main()，该函数是程序的入口和出口。**函数之间是平行关系**

语句：**语句是组成程序的最小单位**。**C语言本身没有输入/输出语句**，C语言的输入/输出操作由scan函数和printf函数等库函数完成。语句**必须以分号结束**。只有分号构成的语句叫空语句，也被编译执行

==基本语法成份==

字符集：英文字母、数字、特殊符号

标识符：分为标准标识符和自定义标识符，必须先定义后使用

* 标准标识符：由系统预先定义的标识符，包括函数名
* 自定义标识符命名规则：
	1. 由数字、英文字母、下划线构成，只能以英文字母、下划线开头
	2. 可以与标准标识符同名
	3. 不能使用关键字，区分大小写

关键字：![[Pasted image 20240904195351.png|608]]、

运算符：+、-、\*、/、sizeof(求字节运算符)等等

* 根据运算对象的个数不同，可分为单目运算符、双目运算符和三目运算符又称为一元运算符、二元运算符和三元运算符

## 计算机中的存储单元

在计算机内部，**数据以二进制的形式存储和运算**。任何形式的数据，输入到计算机中都必须进行**0和1**的二进制编码转换数据的最小单位是二进制的一个数位，**记为bit或b**。为了度量信息存储容量将8位二进制码(8 bits)称为一个字节(Byte，简称B)，**字节是计算机中数据处理和存储容量的基本单位**

### 进制转换

尾符：用于识别进制数，二-B、八-O/Q、十-D、十六-H

非十转十：每位×对应数$^{位数-1}$后相加

十转非十：

* 整数部分：短除法，一直除对应数至商为0，倒取余数作整数部分
* 小数部分：一直乘对应数，每次乘后取掉整数部分，取到数为0止，正取整数作小数部分

二转八和八转二：三位计为一位(124)和一位转三位

二转十六和十六转二：四位计为一位(1248)和一位转四位

* 不够位时补位，分两部分：整数部分往前补0，小数部分往后补0

实例：21D=_Q，答案：25
 ![[Pasted image 20240904212236.png|288]] 

实例：0.25D=\_B，答案：0.01

* 0.25×2=0.5，取0
* 0.5×2=1，取1

实例：27.12O = \_H

* 转二：27.12O=010111.001010B
* 补位：00 010111.001010 00
	* 转十六：17.28

### 二级制数的算术、逻辑运算

算术运算：加法+、减法-

* +：逢二进一
* -：借一为二

逻辑运算：逻辑与-$\wedge$或AND、逻辑或-$\vee$或OR、逻辑非-'-'或NOT、异或-$\bigoplus$或XOR

* 逻辑与：一假则假(0假1真)
	* 101101 $\wedge$ 110100 = 100100
		*   $$\begin{aligned}101101\\\underline{\wedge110100}\\100100\end{aligned}$$
* 逻辑或：一真即真
	* 10110101 $\vee$ 10101010 = 10111111
		* $$\begin{aligned}10110101\\\underline{\vee10101010}\\10111111\end{aligned}$$
* 逻辑非：取反
	* -1011011 = 0100100
* 异或：相同为0，不同为1
	* 10110101 $\bigoplus$ 10101010 = 
		* $$\begin{aligned}10110101\\\underline{\bigoplus10101010}\\00011001\end{aligned}$$

# 数据类型

 ## 数据类型

数据类型可分为：基本数据类型、构造数据类型、指针类型、空类型

基本数据类型：

| 关键字            | 类型  | 符号  | 字节数 | 所占位数 | 数的表示范围       |
| -------------- | --- | --- | --- | ---- | ------------ |
| char           | 字符型 | 有   | 1   | 8    | -128~127     |
| unisgned char  | 字符型 | 无   | 1   | 8    | 0~255        |
| (signed) short | 整型  | 有   | 2   | 16   | -32768~32767 |
| (signed) int   | 整型  | 有   | 2/4 | 16   | -32768~32767 |
| (signed) long  | 整型  | 有   | 4   | 32   |              |
| unisgned int   | 整型  | 无   | 2/4 | 16   | 0~65535      |
| unisgned short | 整型  | 无   | 2   | 16   | 0~65535      |
| unisgned long  | 整型  | 无   | 4   | 32   |              |
| float          | 实型  | 有   | 4   | 32   |              |
| double         | 实型  | 有   | 8   | 64   |              |

* 有符号数和无符号数区别：
	* 有符号数：
		* 二进制表示将第一位作为符号位(0正1负)，其余为数值位
		* 在计算机中以补码形式存储
		* n位取值范围：$-2^{n-1}\sim2^{n-1}-1$
	* 无符号数：
		* 二级制表示将所有位数作为数值位
		* 在计算机中以原码形式存储
		*  n位取值范围：$0\sim2^n-1$
* int所占字节数与编译器与平台有关：若是Turbo C和16位计算机，则视为2字节；其它情况视为4字节

构造数据类型：数组类型(\[])、结构体类型(struct)、共用体类型(union)、枚举(enum)

空类型：void

## 原、反、补码

有符号数在计算机中有三种表示方法，即原码、反码和补码。任何正数这三种码的形式相同，只是负数有各自的不同表示形式

* 原码：二级制表示
* 反码：正数：同原码；负数：将数值位逐个取反
* 补码：正数：同原码；负数：在反码的基础上+1
* 原码求补码和补码求原码：都是先取反后+1

|     | +1       | -1       | +127     | -127     | +128 | -128     | +0       | -0       |
| --- | -------- | -------- | -------- | -------- | ---- | -------- | -------- | -------- |
| 原码  | 00000001 | 10000001 | 01111111 | 11111111 |      |          | 00000000 | 10000000 |
| 反码  | 00000001 | 01111110 | 01111111 | 10000000 |      |          | 00000000 | 11111111 |
| 补码  | 00000001 | 01111111 | 01111111 | 10000001 |      | 10000000 | 00000000 | 00000000 |

* 说明：表格采用8位表示，都是有符号数
* 补码循环：其实-128~127在递增循环，故-128补码 = +127补码 + 1
* 0的表示理解：由于0即可以是正数，又可以是负数，所以采用原码存储时有歧义，故应采用补码形式存储有符号数

实例：`int a = 1; printf("%u",a);`(十六位存储)

* 存储形式：补码1111111111111111
* 无符号打印：全部视为数值位作为原码输出
* 转十进制结果：$=2^{15}+2^{14}+2^{13}...+2^0=2^{16}-1=65535$

## 常量与变量

==常量==

常量：在程序运算过程中不变的量

分类：整型常量、浮点型常量、字符型常量、字符串常量、符号常量

整型常量组成：

* 十进制数：由0~9和正负号表示
* 八进制数：由0开头，后跟0~7表示
* 十六进制数：由0x或0X开头，后跟0~9，a~f，A~F表示

实型常量组成：

* 十进制数形式：必须有小数点
* 科学计数法：e前e后都有数，e后必须为整数，e/E均可。如$3e-5=3×10^{-5}$

字符常量组成：

* 单引号括起的 单个普通字符 或 转义字符 以及SACII码值
	* 重要SACII码值：'0'-48，'A'-65，'a'-97，'\\0'-0(但不会打印显示)
	* 重要转义字符：

| 转义字符    | 含义          | 使用           |
| ------- | ----------- | ------------ |
| '\\n'   | 换行          |              |
| '\\b'   | 退格          | 光标退一个覆盖写     |
| '\\r'   | 回车          | 光标退到行首覆盖写    |
| '\\ooo' | 3位8进制代表的字符  | 最多3位数表示的8进制  |
| '\\xhh' | 2为16进制代表的字符 | 最多2位数表示的16进制 |

* 8和16进制中，只是将\\数字转换了而已，结果为'转换'

字符串常量组成：

* 双引号括起，可以为空(空串)，末尾自动添加'\\0'字符，包含转义字符表示
* 存储长度=字符长度+1
* 实例：`printf("%d",sizeof("he\129llo")); //8`，其中'\\12'，'9'，'\\0'各计一位

符号常量定义：`# define 变量名 值;`

* 值视为字符串运算

==变量==

常变量定义(初始化)：`const 数据类型 变量名[ = 值]`

* 特点：值和数据类型不可更改的变量

变量定义：`数据类型 变量名1[, 变量名2,..., 变量名n]`

变量初始化：`数据类型 变量名 = 变量值[,变量2......, 变量n];`

* 错误：`int a=b=c=10;`，只定义了变量a，其余b、c变量未知

## 数据类型转换

自动转换(隐式)(小转大)：

* 不同一起运算时小转大，float视为double，char转换为int时为对应ASCII码值

强制转换(显示)(小转大)：

* 整型→实型时加小数.0，实型→整型时去掉小数部分，char→int时为对应ASCII码值

# 运算符

## 基本运算符

操作数：运算符的操作对象

运算符分类：单目、双目、三目运算符

![[Pasted image 20240905203824.png|247]]

运算符优先级与结合性：
![[Pasted image 20240905204251.png]]

* 运算顺序：大致为单目>双目>三目>逗号
* 逗号运算符优先级最低

==算术运算符==

注意事项：

* 取余：
	* 两个操作数必须为整数
	* 结果正负号与被除数符号相同
	* 0%谁结果都为0
* 自增、自减：
	* ++数：先算后用；数++：先用后算
	* 实例：`int i = 1; int a = (++i) + (++i) + (++i); //a = 4+4+4 = 12`；统一先前缀后运算再后缀

实例：有一个整数345，取它的个位数的表达式为___，取百位数的表达式为___，取十位数的表达式为___

* 个位为 345%10；十位为 345/10%10；百位为 345/100%10

==关系表达式和逻辑运算符==

数字0表示假，非0表示为真

结合优先级：!>&&>||

短路效果：&&前一个确定为假则后一个不执行；||前一个为真则后一个不执行

实例：`int a = 7; printf("%d", 3 < a <5);`

* =1；运行逻辑：3<7返回真(1)，1<5返回真(1)

实例：判断该年是否为闰年

* `((year%4==0)&&(year%100!=0)||(year%400==0)`

实例：判断回文数

* 回文数：从左到右和从右到左排序都一样的数，为奇数个位数
* 三位数：`x/100%10==x%10`；五位：`x/10000%10 == x%10 && x/1000%10 == x/10%10`

==三目运算符==

实例：转换大小写

* 转大写：`ch = ch > 'A' && ch < 'Z'? ch : ch-32`；转小写：`ch = ch > 'A' && ch < 'Z'? ch-32 : ch`

==赋值类型转换==

赋值类型转换中二级制数位数的转换：

* (有符号)
	* 低数位数据类型→高数位数据类型：全部到多的上面前面部分使用符号位补充
	* 高数位数据类型→低数位数据类型：多的舍弃前面剩下补充到少的
* 无符号时改为用0补位

==逗号运算符==

使用：`表达式1, 表达式2,..., 表达式n;`取最后一个表达式的结果(通常与小括号搭配)

## 位逻辑运算

位逻辑运算只对二进制数进行运算

==按位取反运算(~)==

计算：对二进制数进行取反，0变1，1变0

实例：`~25`

* 25的补码：0000 0000 0001 1001
* 取反：1111 1111 1110 0110
* 转换为十进制：再求原码：1000 0000 0001 1010 = -26

==按位与运算(&)==

计算：全1为1，有0则0

实例：`0x29 & 0x27`

* 0x29二进制数表示：0000 0000 0010 1001；0x27二进制数表示：0000 0000 0010 0111
* $$\begin{aligned}0000\ 0000\ 0010\ 1001\\\underline{\&0000\ 0000\ 0010\ 0111}\\0000\ 0000\ 0010\ 0001\end{aligned}$$
* 转为十六进制表示结果：0x21

应用：`a&0`——将a清0

==按位或运算(|)==

计算：有1为1，全0则0

==按位异或运算(^)==

计算：相同为0，不同为1

应用：两数互换
```C
int a, b;
// 方式一：中间变量
int t;
t = a;
a = b;
b = a;

// 方式二：按位异或运算
a = a ^ b;
b = a ^ b;
a = a ^ b;

// 方式三：加减法
a = a + b;
b = a - b;
a = a - b;
```

==移位运算(<<和>>)==

本质：二进制数左右移动，然后补位

左移位运算计算：`a << n`，$a=a×2^n$(正负数适用)

右移位运算计算：`a << n`，$a=a÷2^n$(只适用正数)

拓展：位复合赋值运算符：&=、|=、^=、>>=、<<=

# 输入输出函数

## printf输出函数

格式：`printf("格式化字符串",输出表列);`

* 当输出表列中数量大于所使用格式说明符时，多余的输出不用理会

普通输出：

| 格式说明符 | 作用                 |
| ----- | ------------------ |
| %d    | 输出有符号整数            |
| %u    | 输出无符号十进制整数         |
| %c    | 输出字符               |
| %s    | 输出字符串              |
| %f    | 输出具有六位小数部分的小数      |
| %o    | 输出八进制整数(不输出前导符0)   |
| %x/%X | 输出十六进制整数(不输出前导符0x) |

指定宽度输出：

| 特殊格式说明符 | 说明                                                              |
| ------- | --------------------------------------------------------------- |
| %md     | 右对齐，前补空格至宽度为m，如果实际位数>m则打印全部                                     |
| %-md    | 左对齐，后补空格至宽度为m，如果实际位数>m则打印全部                                     |
| %m.nf   | 指定小数部分为n位(不足补0，多出则四舍五入)，右对齐，<br>前补空格至宽度为m(小数点占1位)，如果实际位数>m则打印全部 |
| %-m.nf  | 指定小数部分为n位(不足补0，多出则四舍五入)，左对齐，<br>后补空格至宽度为m(小数点占1位)，如果实际位数>m则打印全部 |

==字符输出函数putchar==

基本语法：`putchar(字符变量);`

* 功能：相当于`printf("%c",变量);`

## scanf输入函数

格式：`scanf("键盘输入内容",变量地址表列)`

* (除字符外)格式说明符键盘录入时需要用间隔符(空格、TAB、回车)将每个赋值变量隔开
* 当键盘输入内容用逗号分隔时，输入的数据也要有逗号对应

普通输入：

| 格式说明符 | 作用                  |
| ----- | ------------------- |
| %d    | 要求输入有符号整数           |
| %c    | 要求输入字符              |
| %s    | 要求输入字符串             |
| %f    | 要求输入float类型数据       |
| %lf   | 要求输入double类型数据      |
| %o    | 要求输入八进制整数(不带前导符0)   |
| %x/%X | 要求输入十六进制整数(不带前导符0x) |

指定截取位数：

| 特殊格式说明符 | 说明                      |
| ------- | ----------------------- |
| %md     | 自动识别截取输入的m位整数，从而后面不用间隔符 |
| %mf     | 自动识别截取输入的m位数，从而后面不用间隔符  |

* 注意：在输入小数时，不能指定输入的小数位数。例：`scanf("%5.2f",&f);`

==字符输入函数getchar==

基本语法：`变量 = getchar();`

* 功能：输入一个字符赋值给变量

# 程序与算法

## 算法

算法是对特定问题求解步骤的一种描述，他是指令的有限序列，其中每条指令表示一个或多个操作

算法的特征：

* 有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都可在有穷时间内完成
* 确定性：算法中每一条指令必须有确切的含义，读者理解时不会产生二义性。并且在任何条件下，算法只有唯一的一条执行路径，即对于相同的输入只能得到相同的输出
* 可行性：算法中的每一个步骤都应该能有效地执行，并能得到确定的结果，
* 零或多个输入：一个算法有零个或多个输入，这些输入取自某个特定的对象集合
* 一或多个输出：一个算法有一个或多个输出，这些输出是同输入有着某些特定关系的量

算法的设计要求：

* 正确性：要求算法能够正确地执行预先规定的功能，并达到所期望的性能要求
* 可读性：为了便于理解、测试和修改算法，算法应该具有良好的可读性
* 健壮性：算法中拥有对输入数据、打开文件、读取文件记录、分配内存空间等操作的结果检测，并通过与用户对话的形式做出相应的处理选择
* 时间与空间效率：算法的时间与空间效率是指将算法变换为程序后，该程序在计算机上运行时所花费的时间及所占据空间的度量

## 程序

程序的三种基本结构：顺序结构、选择(分支)结构、循环结构

选择结构：包括单分支`if...`、二分支`if...else...`、多分支`if...else if...`

循环结构：分为当型循环和直到型循环

* 当型循环：循环体可能一次不执行。例：for循环和while循环
* 直到型循环：循环体至少执行一次。例：do...while循环

## 特殊语句

==注释语句==

单行注释：`//...`

多行注释：`/*...*/`

==复合语句==

格式：`{}`

* 函数体从一般意义上讲就是一条复合语句

==空语句==

格式：`;`

* 仅有分号构成，编译时不产生任何指令，执行时不产生任何操作

实例：`for( ; ; ;);`

## if语句

格式：
```c
if(expression)
{	
	statement;
}
```

* if和else下只有一条语句时，可以省略大括号不写
* 两个等价if表达：`if(x)`等同于`if(x!=0)`；`if(!x)`等价于`if(x==0)`

if-else的嵌套使用：

* 规范使用：每个对应if或else使用{}括起
* 缺省{}时：找else，它与最近的if组合成一对

实例：
```c
if(score>=60) 
	printf("及格\n"); 
	if(score>90) 
		printf("优秀\n");
else 
	printf("不及格\n");
```

* 错误：else与第二个if进行了配对，导致80分时既及格又不及格

## switch语句

格式：
```c
switch(表达式)
{
case 常量1:语句1;break;
case 常量2:语句2;break;
...
default:语句组;break;
}
```

* switch后的表达式可以是常量表达式或数据类型为整型和字符型，但要求不能是实型；case后的常量类型应与switch后的类型一致
* break：是跳出整个复合语句，没有break会继续执行下一个语句组
* default：功能是在其他case后找不到对应常量，则执行default后面语句，与该语句顺序无关（通常放最后面从而不加break）
* switch嵌套：一个break对应跳出一个switch复合语句

实例：switch嵌套
```c
void main()
{
	int x=1,y=0,a=0,b=0;
	switch(x)
	{ case 1:
		switch(y)
		{ case 0:a++; break;
		 case 1:b++; break;
		}
	 case 2:a++;b++; break;
	 case 3:a++;b++;
	}
	printf("\na=%d,b=%d,",a,b); //a=2,b=1
}
```

* 说明：由于case 1的语句组后没有break，case1发生了穿透，同时执行了case2

## while语句

格式1：
```C
while(表达式)
{
	循环体语句：
}
```

格式2：
```C
do
{
	循环体语句;
}
while(表达式);
```

* 次数：与while的计算方式一样，但`do...while`至少执行一次

应用：辗转相除法——找两个数的最大公约数

* 步骤：两数相除取余，如果余数不为0，则再使用除数取余余数，一直到余数为0时，此时除数为所求值
```C
void main()
{
	int a,b,c;
	int t;
	scanf("%d%d",&a,&b);
	if(a<b) //判断除数和被除数大小以作正确取余
	{
		t=a;
		a=b;
		b=t;
	}
	c=a%b;
	while(c)
	{
		a=b;
		b=c;
		c=a%b;
	}
	printf("最大公约数为：%d",b);
}
```

## for语句

格式：
```c
for([expr1];[expr2];[expr3])
{
	循环体语句;
}
```

* 当循环体语句只有一句时，可以省略大括号

## goto语句

goto标志：`标号：`

goto语句：`goto 标号;`

用途：与if语句实现循环；内层循环跳到外层循环

# 数组

## 一维数组

定义：`数据类型 数组名[元素个数];`

* 定义时必须有数组长度
* 元素个数：定义时只能是整型常量或符号常量，不能为变量和浮点数
* 数组存储大小：一个数据所占字节×元素个数
* 默认值：整数-0，小数-0.0，字符-'\\0'

初始化：`数据类型 数组名[元素个数] = {元素值表列}`

* 初始化时可以省略元素个数不写
* 元素值表列必须至少有一个值

### 应用

#### 数组悲波那契数列

```C
#include "stdio.h"

void main()
{
	int a[20]={1,1};
	int i;
	for(i=2;i<=19;i++)
		a[i]=a[i-1]+a[i-2];
	for(i=0;i<20;i++)
	{
		printf("%6d",a[i]);
		if((i+1)%5==0)
			printf("\n");
	}
}
```

* 只有20个数

#### 冒泡排序

升序版：从左往右，大的往后冒泡
```C
void main()
{
	int a[10]={10个数}
	int t,flag; //作为交换结束标记
	for(int i=;i<=9;i++)
	{
		flag=0;
		for(int j=0;j<=9-j;j++)
		{
			if(a[j]>a[j+1])
			{
				t=a[j];
				a[j]=a[j+1];
				a[j+1]=t;
			}
		}
		if(flag==0)
			break;
	}
}
```

* flag作用：在遍历了整个数组后发现不需要交换，则flag=0直接break整个外层遍历
* 降序版：从左往右，小的往后冒泡。操作：只需将内层循环的if中>改为<