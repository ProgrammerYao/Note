
## C语言的特点

1. C语言**简洁、紧凑**，压缩了一切不必要的成份
2. C语言**运算丰富**，将括号、赋值、强制类型转换、取变量地址等都以运算实现
3. C语言**数据类型丰富**，具有现代语言的各种数据类型；用户能扩充数据类型，能够实现各种复杂的数据结构，完成各种问题的数据描述
4. C语言是一种**结构化程序设计语言**，具有结构化语言所要求的三种基本结构(顺序、选择 循环)
5. C语言是**高级语言中的低级语言**。C语言**允许直接访问物理地址**，能进行位运算，能实现汇编语言的大部分功能，能直接对硬件进行操作
6. C语言提供**编译预处理机制**，有利于大程序的编写和调试
7. C语言编译系统小，生成的目标代码质量高，程序的**执行效率高**
8. C语言的输入和输出功能用库函数实现，编写的程序**移植性好**，能够在**不同操作系统**下运行
9. C语言**语法限制不太严格**，程序设计自由度大，对程序员要求较高

：具有兼容性和移植性特点，移植性表现能够在不同操作系统下运行

# 前置知识

## 进制转换

==介绍==

进制：二进制、八进制、十进制、十六进制

* 八进制数范围：0~7
* 十六进制数范围：0~9、A~F/a~f

进制脚标：二级制—B 或 $(\ )_2$，八进制—Q 或 $(\ )_8$，十进制—D 或 $(\ )_{10}$，十六进制—H 或 $(\ )_{16}$

* 十进制数脚标可省略
* 记忆：BBQdh

==转换==

非十转换为十：按权展开，个位为0次方，负数后第一位为-1次方

十转非十：整数部分—短除法(转几除几，除至商为0)，结果倒取余数；小数部分—转几乘几，每次取整数部分，直至小数部分为0，结果为正摆所有整数部分

二进制、八进制、十六进制互相转换：

* 3位二进制转1位八进制，整数部分不足前补0，小数部分不足后补0
* 4位二进制转1位十六进制，整数部分不足前补0，小数部分不足后补0
* 反之1位八进制转3位二进制；1位十六进制转4位二进制
* 注意：转换为八进制数或十六进制数时需要0或0x符前导

实例：$(52.2)_8=(\ )_{10}$ (八转十)

* 解析：$整数：5×8^1+2×8^0=42;小数=2×8^{-1}=0.25;结果=42.25$

实例：$(5.625)_{10} = ()_2$(十转非十)

* 解析：
	* 整数：
		* $5 ÷ 2 = 2$ 余 1
		- $2 ÷ 2 = 1$ 余 0
		- $1 ÷ 2 = 0$ 余 1
		- 倒取余数为101
	- 小数：
		- $0.625 × 2 = 1.25$，取整数部分 1
		- $0.25 × 2 = 0.5$，取整数部分 0
		- $0.5 × 2 = 1.0$，取整数部分 1
		- 顺序摆放为101
	- 结果：101.101

## 原、反、补码

有符号数在计算机中有三种表示方法，即原码、反码和补码，其中使用补码进行存储

* 原码：二级制表示(最左边一位为符号位0正1负，其余为数值位)
* 反码：正数：同原码；负数：将数值位逐个取反
* 补码：正数：同原码；负数：在反码的基础上+1
* 补码求源码：正数不变；负数逆运行即可(-1再取反)

无符号数只有正数值，只用原码表示和存储

实例：计算 -5 的补码

* 原码：1000 0101
* 反码：1111 1010
* 补码：1111 1010

实例(无符号打印)：`int a = -1; printf("%u",a);`(十六位存储)

* 存储形式：补码1111111111111111
* 无符号打印：全部视为数值位作为原码输出
* 转十进制结果：$=2^{15}+2^{14}+2^{13}...+2^0=2^{16}-1=65535$

# 程序设计语言

### 概述

**程序 = 算法 + 数据结构**

算法：可以看作是由**有限个步骤组成的用来解决问题的具体过程**。算法有三种基本结构，分别是**顺序结构、选择结构和循环结构**

数据结构：是从问题中抽象出来的数据之间的关系，它代表信息的一种组织方式。反映一个数据的内部结构，其目的是提高算法的效率，它通常与一组算法的集合相对应，通过这组算法集合可以对数据结构中的数据进行某种操作。典型的数据结构包括线性表、堆栈和队列

程序：对问题的**具体代码实现**

计算机语言分类：**机器语言、汇编语言、高级语言**（**机器语言和汇编语言统称为低级语言**)

机器语言：**是机器能直接识别的程序语言或指令代码**，它直接由**0或1**这样的二进制数值进行编码。从系统结构的角度看，它是系统程序员看到的计算机的主要属性。指令系统表征了计算机的基本功能同时也决定了机器所能被要求的能力，也决定了指令的格式和机器的结构。机器语言由于可以被计算机直接识别并执行，所以它的执行效率很高，但是因为它是基于计算机指令系统的程序语言，所以可移植性很差

汇编语言：采用一定的**助记符**来代替机器语言中的指令和数据，又称为符号语言。汇编语言一定程度上克服了机器语言难读难改的缺点，同时保持了其编程质量高、所占存储空间小、运行速度快的优点。故在程序设计中，对实时性要求较高的地方，如过程控制等，仍经常采用汇编语言，该语言也依赖于机器，不同的计算机一般也有着不同的汇编语言

用高级语言编写的程序易学、易读、易修改、通用性好，**不依赖于机器**，但**机器不能对其编制的程序直接运行**，必须经过语言处理程序的翻译后才可以被机器接受。高级语言的种类繁多，如面向过程的Fortran、Pascal、**C**等，面向对象的C++、Java、Visual BASIC等

### 语言处理程序

针对不同的程序设计语言编写出的程序，它们有各自的翻译程序，互相不通用

==汇编程序==

汇编程序是将汇编语言编制的程序(源程序)翻译成机器语言程序(目标程序)的工具。将汇编语言源程序转换为等价的目标程序的过程称为汇编

==高级语言翻译程序==

高级语言翻译程序是将高级语言编写的源程序翻译成目标程序的工具。**翻译程序有两种**工作方式：**解释方式和编译方式**。相应的翻译工具也分别称为解释程序和编译程序

解释：解释程序是对源程序**一边翻译、一边执行，不产生目标程序**。解释程序对源程序进行逐句分析，若没有错误，将该语句翻译成一个或多个机器语言指令，然后立即执行这些指令;若当它解释时发现错误，会立即停止，报错并提醒用户更正代码。早期的BASIC语言采用解释方式

编译：将高级语言所编写的**源程序翻译成机器语言表示的目标程序**。源程序经过编译处理，会产生一个与源程序等价的目标程序，但目标程序还不能直接执行，通过**链接**程序将目标程序和有关的程序库组合成完整程序**后才可以执行**。最终产生的可执行程序可以脱离编译程序和源程序独立存在并反复使用，大多数高级语言都是采用编译方式

==C语言编译过程==

![[Pasted image 20240904185811.png]]

**过程**：编辑 -> 源程序(.c文本文件) - 编译 ->目标文件(.obj二进制文件) - 链接 -> 可执行文件(.exe二进制文件) - 执行

* **其中源程序，目标程序不能被计算机直接执行，只有可执行文件能够被直接执行**

**C程序可以由多个程序文件组成**

一个源程序文件中包括3个部分：**预处理指令、全局声明和函数定义**

结构化程序设计方法的主要原则有：**模块化、自顶向下、逐步求精**

## C程序结构和基本语法成份

==C程序结构==

```C
# include <stdio.h>

int main() //函数头
{

	return 0;
} //函数体

// 单行注释

/*
	多行注释
*/
```

函数：C语言程序由若干函数组成，**函数是C程序的基本单位**。**必须有且只有一个主函数main()**，该函数是**程序的入口和出口**。**函数之间是平行关系**

语句：**语句是组成程序的最小单位**。**C语言本身没有输入/输出语句**，C语言的输入/输出操作由scan函数和printf函数等库函数完成。语句**必须以分号结束**。只有分号构成的语句叫**空语句**，也被编译执行。一行可写一条或多条语句，一条语句也可写成一行或多行

# 核心语法

## 注释

在C语言中，对**编译和运行不起作用**的是**注释**

单行注释：`//内容`

多行注释：`/* 内容 */`

## 标识符

标识符由**数字**(0~9)、**字母**(a~z,A~Z)、**下划线**组成，并且**首字母不能是数字**。**字母区分大小写**

标识符分类：**关键字、预定义标识符、用户标识符**

关键字：32个，均为小写![[Pasted image 20241016212301.png]]

预定义标识符：C语言中系统预先定义的标识符，如函数库中的函数名、宏定义和类型别名。如：define、scanf、printf、include

用户标识符：用户根据需要自己定义的标识符。一般用来给变量、函数、数组等命名。**关键字不能作为用户标识符**

## 常量、变量与常变量

### 常量

含义：在运行程序过程中，其值不能被改变的量称为常量

分类：整型常量、浮点型常量、字符型常量、字符串常量、符号常量

整型常量表示：**八进制**用前导0，**十六进制**用0x或0X表示

实型常量表示：

* 十进制数形式：必须有小数点，至少一边是数字
* 科学计数法：e前e后都有数，e后必须为整数，e/E均可

字符常量：

* 单引号(' ')括起的 单个普通字符 或 转义字符
	* 常用ASCII码：'A'-65，'Z'-112，'a'-97，'z'-90，'0'-48（大小写字母ASCII码相差32）
	* 注意：区分运算中的数字与字符。例：`'0'`计算时为48，而`0`计算时为0
	* 重要转义字符：

| 转义字符    | 含义                   | 注意                    | 例子                           |
| ------- | -------------------- | --------------------- | ---------------------------- |
| '\\n'   | 回车换行                 |                       |                              |
| '\\t'   | 横向跳格，该制表符会占用4个空格位置   |                       |                              |
| '\\b'   | 退格                   | 退格后会覆盖内容，一个新字母只覆盖一个旧的 | `printf("abc\b\bXY"); //aXY` |
| '\\\\'  | 反斜杠                  |                       |                              |
| '\\''   | 单引号                  |                       |                              |
| '\\"'   | 双引号                  |                       |                              |
| '\ddd'  | 1至3位八进制表示的1个字符的ASCLL | 最多使用三位表示八进制           | `'\101'='A'`                 |
| '\\xhh' | 1至2位十六进制表示的1个字符ASCLL | 最多使用两位表示十六进制          |                              |

字符串常量：

* 由双引号(" ")括起，双引号中可以没有内容，每个字符串结尾都有隐藏的'\\0'表示字符串的结束，占1个字节
* 注意：字符串常量中每个字符都可以看做一个字符常量，故需注意多位计1位的转义字符
* 实例：`printf("%d",sizeof("he\129llo")); //8`，其中'\\12'，'9'，'\\0'各计一位

区分字符常量和字符串常量：分别由单引号和双引号括起，其中字符常量只能为一个字符

符号常量定义：`#define 变量名 值;`

* 在预编译时处理，作简单的字符串替换

### 变量

含义：指在程序运行过程中其值可以改变的量，可以在程序运行过程中给它们赋予新的值。

类别：分为**局部变量**和**全局变量**，并且有不同的数据类型和存储类别

使用前提：变量必须先定义后才能被使用，并且局部变量必须初始化(没有默认值)；全局变量可以不初始化(有默认值)

#### 语法

定义：`类型 变量名1 [, 变量名2, ...];`

* 定义位置：当定义在函数内为局部变量，函数外时为全局变量

赋值：`变量名 = 常量;`

初始化：`类型 变量名 = 常量;`

多个初始化：`数据类型 变量名1 = 数据值1[, 变量名2 = 值2];`

#### 变量属性(作用域、生存期、存储类)？

##### 作用域

局部变量：在函数内部定义的变量，包括形参

作用域：从定义的位置到函数的 } 处

全局变量：在函数的外部定义的变量

作用域：从定义的位置到整个程序结束

注意：在同一作用域的两个同名的局部变量和全局变量，使用时为局部变量

##### 生存期和存储类

==生存期(生命周期)==

根据变量的生存期来辨别存储方式分为两种：静态存储方式和动态存储方式(寄存器另计)

静态存储方式：指在程序运行期间由系统分配固定的存储空间的方式，直到整个程序结束

动态存储方式：指在程序运行期间根据需要进行动态的分配存储空间的方式，函数调用时临时分配内存，函数结束时释放

* 注意：由于是动态存储，所以每次调用函数时重新定义该变量，所以每一次变量的地址不相同

==存储类别==

基本语法：`存储类别 数据类型 变量名;`

`auto`自动变量：采用动态存储方式。局部变量**默认**使用了该存储类别

* 不能用于全局变量

`static`静态变量：分为静态局部变量和静态全局变量。静态局部变量：改用静态存储方式存储该变量；静态全局变量：全作用域只是在其定义的源文件中有效，不能被外文件extern

* 只定义时会有默认初始值
* 全局变量不带存储类别时，默认使用了static，然而是隐式地使用，只改变了生存期
* 当调用函数时定义了静态局部变量后，第二次调用的定义语句无效

`register`寄存器变量(了解)：建议将定义的变量放在CPU的寄存器中；寄存器的存取速度远高于内存，从而提供执行效率

* 作用对象：局部变量

`extern`外部变量：将全局变量的定义声明到该extern处，包括从其他文件的全局变量，从而扩大全局变量的作用域

* 作用对象：所有源文件的全局变量
* 使用：声明时不能使用，声明后才可以正常使用

### 常变量

常变量：具有数据类型和名字的常量

定义：`const 数据类型 常变量名;`

定义并赋值：`const 数据类型 常变量名 = 值;`

特点：不能更改其值和数据类型

## 数据类型

### 介绍

C语言中三种基本数据类型：**整型**、**实型**、**字符型**

==整型==

| 关键字              | 类型   | 占用字节                                            | 后缀     |
| ---------------- | ---- | ----------------------------------------------- | ------ |
| int              | 基本型  | TurboC占2个字节(16位编译器)<br>VC++系统下占**4个字节**(32为编译器) |        |
| short(short int) | 短整型  |                                                 |        |
| long(long int)   | 长整型  |                                                 | 必须要l或L |
| unsigned         | 无符号型 |                                                 |        |

* 无符号型变量定义：`signed/unsignde 数据类型 变量名;`
* 对应无符号型用“%u”格式输出，表示用无符号十进制数的格式输出

存储：在内存中以**补码**的形式存储的

==实型==

| 关键字         | 类型                    | 占用字节 |
| ----------- | --------------------- | ---- |
| float       | 单精度浮点型(float型)        | 4个字节 |
| double      | 双精度浮点型(double型)       | 8个字节 |
| long double | 长双精度浮点型(long double型) |      |

==字符型==

| 数据类型 | 字节数 |
| ---- | --- |
| char | 1   |

存储：在内存中是以其对应的 **ASCII** 编码值存储的

==其它==

空类型-void

### 数据类型转换

整型和字符型可以相互转换

示例：
```c
printf("%d", 'a');  //97
printf("%c", 97);  //a
```

#### 隐式转换

触发条件：当进行不同数据类型的运算时，最终结果为占用字节最多的数据类型

* 运算前，char和short类型会直接先提升为int，然后再进行运算

#### 强制转换

使用条件：如果把取值范围大的，赋值给取值范围小的，就需要进行强制转换

使用：`数据类型 变量 = (转换类型)变量;`

注意：将小的转换为大的数据不会变化，但将大的转换为小的数据可能出问题。原因：大字节数据会丢掉前面部分字节使其变为小字节数据

比较：`(int)(a+b)`和`(int)a+b`

* 前是把 a+b 转型，后是把 a 转型再加 b

题型：数学公式转换

* 数学符号与函数：
	* 根号：`sqrt(num)`。例：`sqrt(b*b-4ac)`表示$\sqrt{(b^2-4ac)}$
	* 幂：`pow(num1, num2)`。例：`pow(x,2)`表示$x^2$
	* 绝对值：`abs(num)`。例：`abs(x)`表示$|x|$
	* 三角函数？
* 注意：
	* C表达式乘法时不能省略`*`
	* C表达式只有小括号没有中括号
	* 整型除法转换中，在进行第一次除时就进行实型转换，否则会丢失精度。实型或不确定除法转换时就不需要
		* 实例：$\frac{1}{abc}(a、b、c为整型)$表达式为`1.0/a/b/c`

## 复合语句和空语句

单语句：使用`;`结尾

复合语句：由多个语句用{}括起

* 说明：复合语句在语法上视为一个语句

空语句：`;`

## 基本运算符

C语言中，0表示假，非0表示真

* 记忆：多个真一个假

**表达式**中的真假：表达式的数值结果默认为 1（表示为真），或 0（表示假）

实例：`pirntf("%d", 1<0<2);  //1`

* 过程：先计算1<0结果为0，再计算0<2结果为1

### 介绍

操作数：运算符的操作对象

运算符分类：单目、双目、三目运算符

![[Pasted image 20240905203824.png|262]]

* 没有$\leq$，只有<=

运算符**优先级**与**结合性**：决定表达式计算顺序的两个因素
![[Pasted image 20240905204251.png|638]]

* 优先级记忆：单目>双目>三目>赋值>==>=>逗号
* 特记：&>|>&&>||
* 同级结合律特记：带一个=赋值是从右向左运算

带两种用法的符号：

* &：取地址运算符 或 按位与运算
* \*：指针运算 或 乘法运算

### 使用及注意事项

==赋值运算符==

注意：

* =：=号前面不能为常量和运算式

==算术运算符==

注意：

* /：都是整型结果为整型，有一实型结果为实型。两个整数相除时结果会舍弃小数部分
* %：要求**前后都为整数**，结果**符号与被除数的相同**
	* 特殊使用：获取某个数的某位数时，前除以某在取余10即可获得。例：获取345的十位数为`345/10%10`

实例：判断回文数

* 回文数：从左到右和从右到左排序都一样的数，为奇数个位数
* 实例：三位个：`x/100%10==x%10`；五位个：`x/10000%10 == x%10 && x/1000%10 == x/10%10`

==自增自减运算符==

格式：`++变量`、`变量++`、`--变量`、`变量--`

* 区别：先加后用与先用后加，求表达式结果时也影响
* 注意：
	* 只能用于变量，不能用于常量(包括符号常量)
	* 多个+号时前一个变量优先结合最多+号。例：`a+++b`为(a++)+b
	* 表达式中++和加减乘除一起运算时，优先计算++的部分

例子：定义：`double x = 3.4, y = 3.2；`表达式y+=x++的值是

* 答案：6.6
* 注意：问的是y的值，而y并没有++

==逻辑运算符==

格式：`表达式1 运算符 表达式2;`

* 结果：为真返回1，否则返回0
* 短路效果：&&前一个确定为假则后一个不执行；||前一个为真则后一个不执行

==条件运算符==

格式：`表达式 ? 值1 : 值2;`

* 说明：表达式为真返回值1，否则返回值2

实例：转换大小写

* 转大写：`ch = ch > 'A' && ch < 'Z'? ch : ch-32`
* 转小写：`ch = ch > 'A' && ch < 'Z'? ch-32 : ch`

==逗号运算符==

格式：`(表达式1,表达式2,……,表达式n)`

* 说明：自左向右顺序求值，将最后表达式n的值作为整个表达式的值
* 注意：没有括号时逗号为分隔符，此时结果不为最后一式
* 区别：`int z;z=2,3,4;  //2`和`z=(2,3,4)  //4`

==求字节运算符==

格式：`pirntf("%zu",sizeof(数据类型/变量));`

* 使用：会统计字符数组结尾'\\0'为一个字节

### 位运算

位运算是对整数的二进制(补码)表示直接进行操作的运算

| 运算符 | 含义   |             | 例子                                         |
| --- | ---- | ----------- | ------------------------------------------ |
| &   | 按位与  | 有0为0，全1为1   |                                            |
| \|  | 按位或  | 有1为1，全0为0   |                                            |
| ^   | 按位异或 | 相同为0，不同为1   |                                            |
| ~   | 取反   | 0取反为1，1取反为0 |                                            |
| <<  | 左移   | 左去N位，右补N个0  | `a = 3(0000 0011)`<br>`a<<2=12(0000 1100)` |
| >>  | 右移   | 右去N位，左补N个0  |                                            |

* 优先级：~、<<、>>、&、^、|

计算：由于是对二进制进行运算，故当为其它整数时需先转换为二进制，并且是对补码进行运算，故还需要区分正负数

计算规则：十进制的取反与左右移

* 十进制数取反规则：$~a=-(a+1)$
* 正数十进制左右移计算规则：左移N位相当于$×2^{N}$，右移N位相当于$÷2^{N}$

复合位运算：&=、|=、^=、<<=、>>=

位运算特点：

| 运算符 | 0      | 1   |
| --- | ------ | --- |
| &   | 清0(变0) | 不变  |
| \|  | 不变     | 置1  |
| ^   | 不变     | 求反  |

* 记忆主要功能：清0、置1、求反
* 实例：
```
能将1字节变量x的高4为全置成1，低4位字节保持不变的表达式是  x|11110000

能将1字节变量x的高4为保持不变，低4位清0的表达式是  x&11110000
```

## 输入和输出函数

C语言本身没有输入输出语句，需要调用标准库函数来完成，引入头文件"stdio.h“，格式为`# include <stdio.h>`

### printf格式输出函数

基本语法：`printf("格式化字符串"，输出表列)`

* 特殊：纯输出字符串可以直接 `printf("内容")` 表示
* 换行：可以在格式化字符串末尾加\\n；或者可直接使用独立语句`printf("\n");`
* 字符和字符串输出：输出时不会含有(' ')或(" ")
* 注意：当输出表列中数量大于所使用格式说明符时，多余的输出不用理会

普通输出：

| 格式说明符   | 作用                 |
| ------- | ------------------ |
| %d      | 输出有符号整数            |
| %u      | 输出无符号十进制整数         |
| %c      | 输出字符               |
| %s      | 输出字符串              |
| %f与%lf  | 输出具有六位小数部分的小数      |
| %o      | 输出八进制整数(不输出前导符0)   |
| %#o     | 输出八进制整数(输出前导符0)    |
| %x或%X   | 输出十六进制整数(不输出前导符0x) |
| %#x或%#X | 输出十六进制整数(输出前导符0x)  |

指定宽度输出：

| 特殊格式说明符 | 说明                                                              |
| ------- | --------------------------------------------------------------- |
| %md     | 右对齐，前补空格至宽度为m，如果实际位数>m则打印全部                                     |
| %-md    | 左对齐，后补空格至宽度为m，如果实际位数>m则打印全部                                     |
| %m.nf   | 右对齐，指定小数部分为n位(不足补0，多出则四舍五入)，<br>前补空格至宽度为m(小数点占1位)，如果实际位数>m则打印全部 |
| %-m.nf  | 左对齐，指定小数部分为n位(不足补0，多出则四舍五入)，<br>后补空格至宽度为m(小数点占1位)，如果实际位数>m则打印全部 |

* 注意：可以通过省略m只指定小数的小数部分。例：`.6f`表示只输出六位小数的单精度数

==字符输出函数putchar==

基本语法：`putchar(字符变量);`

* 功能：相当于`printf("%c",变量);`

### scanf格式输入函数

使用前提：除头文件外，还需要`# define _CRT_SECURE_NO_WARNINGS`

基本语法：`scanf("格式化字符串", 输入表列)`

* 格式说明符：与printf中的一致，但double类型需用`%lf`
* 输入表列：是所要赋值的变量等的地址，可以用`&变量`或`指针`，之间用逗号隔开
* 输入对应：当格式化字符串中有特殊字符时，对应键盘输入内容也得有特殊字符
* 输入：各个输入需要使用空格、Tab、回车隔开(除字符输入前后不需要分割)，最后回车结束输入

指定截取位数：

| 特殊格式说明符 | 说明                      |
| ------- | ----------------------- |
| %md     | 自动识别截取输入的m个字符，从而后面不用分隔符 |
| %mf     | 自动识别截取输入的m个字符，从而后面不用分隔符 |
| %mlf    | 自动识别截取输入的m个字符，从而后面不用分隔符 |

* 注意：在输入小数时，不能指定输入的小数位数。例：`scanf("%5.2f",&f);`

## 程序

程序的三种基本结构：顺序结构、选择(分支)结构、循环结构

### 顺序结构

顺序结构是程序默认的执行流程，从上往下依次运行的

### 选择结构

#### if分支

基本语法：
```C
if (关系表达式A)
	语句A;
else if (关系表达式B)
	语句B;
else
	语句C;
```

* 注意：
	* 语句：可以是`{}`括起的复合语句，也可以是`;`结尾的单语句。一个单语句只对应一个前面的`if`或`else`
	* `else`为与之最近的上一个`if`进行配对
	* 整个if分支之间的判断不能存在其它语句，否则为语法错误
	* 每个 `if`、`else if` 分支中，括号里的“条件表达式”都会被执行一次，直到遇到第一个为真的分支为止。

#### switch分支

格式：
```c
switch(表达式)
{
case 常量1:语句1...;break;
case 常量2:语句2...;break;
...
default:语句组;break;
}
``````

* switch要求：后面表达式可以是整型和字符型，但不能是实型
* case要求：case后面只能是常量
* case执行：直至遇到break，不然执行到整个switch结束才停止，并且执行下一个case时不需要进行判断
* break功能：跳出整个switch语句，单独为一个语句
* default功能：如果其他case后找不到对应常量，则执行default后面语句，与该语句与书写顺序无关（通常放最后面从而不加break）。也可以不使用该语句
* switch嵌套：一个break对应跳出一个switch复合语句

### 循环结构

循环三要素：**初值、条件、增量**（使用for循环记忆）

C语言中的三种循环结构（`for`、`while`、`do...while`）是可以互相转换的

#### for循环

基本语法：
```C
for (初始化语句; 条件判断语句; 条件控制语句)
{
	循环体语句;
}
```

* 次数计算：当增量为++且判断不带=时，次数=|结束条件-初值|；带=时多加1

#### while循环和do...while循环

格式1：
```C
while(表达式)
语句;
```

格式2：
```C
do
	语句;
while(表达式);
```

* 主要区别：`do...while`至少无条件执行一次
* 结束：`while`以语句结束；`do...while`以`;`结束

应用：辗转相除法——找两个数的最大公约数

* 步骤：两数相除取余，如果余数不为0，则再使用除数取余余数，一直到余数为0时，此时除数为所求值
```C
void main()
{
	int a,b,c;
	int t;
	scanf("%d%d",&a,&b);
	if(a<b) //判断除数和被除数大小以作正确取余
	{
		t=a;
		a=b;
		b=t;
	}
	c=a%b;
	while(c)
	{
		a=b;
		b=c;
		c=a%b;
	}
	printf("最大公约数为：%d",b);
}
```

### 无限循环语句和break及continue

基本语法1：`for (;;)`

基本语法2：`while (1)`

break：只能写在switch、循环中，用于完全结束一个循环

* 注意：break结束的循环，不会再执行for循环中的条件控制语句

continue：只能写在循环中，表示跳过本次循环，继续执行下次循环

### goto语句?

goto：结合标号，可以跳到代码中的任意地方。一般只用于跳出循环嵌套

实例：
```C
int main()
{
	int i = 1;
a:	
	printf("你好你好%d\n”，i);
	i++;
	goto a;
}
```

* 分析：每当执行到goto语句时，又重新跳到标号a：行中，导致无限循环

# 预处理语句

C语言提供的预处理功能主要有三种：宏定义，文件包含和条件编译

预处理语句以**#**开头

==宏定义==

形式1：`#define 宏名 替换文本`

形式2：`#define 宏名(参数) 替换文本`

说明：宏名习惯用大写字母，但是也可以用小写。宏定义不是C语句，行末不必加分号

形式2实例：
```C
#define f(x) x*x

int a = 6, b = 2;

f(a) + f(b) = 40; //6*6+2*2
f(a+b) = 20; //6+2*6+2
f(a)/f(b) = 36; //6*6/2*2
```

* 方法：先宏替换后计算

==文件包含==

含义：就是指一个源文件可以将另一个源文件的全部内容包含进来，即将另外的文件包含到本文件中

形式1：`#include<文件名>`

形式2：`#include"文件名"`

* 区别：形式1范围包括系统目录；形式2包括用户目录和系统目录

==条件编译==

形式一：判断标识符是否已定义
```C
#ifdef 标识符
	执行语句1;
#else
	执行语句2;
#endif
```

形式二：判断标识符是否没有定义
```C
#ifndef 标识符
	执行语句1;
#else
	执行语句2;
#endif
```

形式三：类型if语句
```C
#if 表达式
	执行语句1;
#else
	执行语句2;
#endif
```

使用位置：函数之中

# 数组

## 语法

==一维数组==

定义：`数据类型 数组名[长度];`

* 定义时必须有数组长度
* 长度：定义时只能是整型常量或符号常量，不能为变量和浮点数
* 数组存储大小：一个元素所占字节×元素个数
* 默认值：整数-0，小数-0.0，字符-'\\0'

初始化：`数据类型 数组名[长度] = {元素值表列};`

* 当元素长度个数确定时，可以不写数组长度
* 注意：
	* 初始化不能拆分为定义和引用，因为引用每次只能引用一个元素
	* 赋值元素的数量≤数组长度，不能大于

==数组使用==

数组使用：`arr[索引]` 或 `arr` 

* 每次只能引用一个元素，不能引用整个数组
* 索引范围：0~(最大长度-1)

==二维数组==

初始化1：`数据类型 数组名[一维长度][二维长度] = {{arr1},{arr2},...};` #C 

初始化2：`数据类型 数组名[一维长度][二维长度] = {值1,值2,值3,值4...};` #C 

* 注意：二维数组的定义可以省略行下标，但不能省略列下标

## 字符数组与字符串与字符串数组

==字符数组与字符串==

知识前提：字符串本质是一个字符数组

字符数组初始化：`char 字符数组名[长度] = {'字符1', '字符2', ...};`

字符串初始化：`char 字符串名[长度] = "内容";`

* 长度(元素个数)区别：
	* 定义的字符串中会隐藏一个结束标记符'\\0'占用一个长度(元素)，所以内容长度=字符数组长度-1，如果长度超出，则会覆盖结束标记符，从而打印错误
	* 定义的字符数组没有'\\0'的结尾标记符，故数组长度等于实际内容长度
* 只定义时需要有长度，初始化时长度可选择不填，内容小于长度时用空字符'\\0'填补位置
* 长度计算：
	* 英文、符号、数字占用一个字节
	* 中文在vs中占用两个字节
	* 结束标记'\\0'：占用一个字节

注意：除定义的"字符"类型的字符串外，其余类型数组没有结束标记符

==字符串数组==

初始化：`char 字符串数组名[一维长度][二维长度] = {"字符串1",  "字符串2", ...};`

==printf打印字符串原理==

原理：printf从指针指向的第一个字符开始，逐个读取字符，直到遇到 `\0` 结束

简易printf函数自定义：
```C
void my_printf(const char *str) {
    while (*str != '\0') {
        putchar(*str); // 打印当前字符
        str++; // 移动到下一个字符
    }
}
```

## 索引遍历数组

==一维数组遍历==

问题：利用循环遍历数组时需要确定数组长度，而过长的数组又不能一一数出

要点：利用sizeof(数组名) / sizeof(数组数据类型)确定数组长度，即数组长度=总数据所占字节/一个类型数据所占字节

```C
int main()
{
	int arr[5] = { 1,2,3,4,5 };
	int len = sizeof(arr) / sizeof(int);
	for (int i = 0; i < len; i++)
	{
		printf("%d\n", arr[i]);
	}
}
```

字符串数组遍历：
```C
char arr[] = "i cash you";

方法一：直接使用字符串名
printf("%s",arr);

方法二：使用结束标记'\0'
int i = 0;
while (arr[i] != '\0')
{
    printf("%c", arr[i]);
    i++;
}
```

==数组作为形成形参时==

注意：数组作为形参时传递的是数组的首地址，故只能将len的计算放到函数外

```C
int main()
{
	int arr[5] = { 1,2,3,4,5 };
	int len = sizeof(arr) / sizeof(int);

	printArr(arr,len);
}

void printArr(int arr[], int len)
{
	for (int i = 0; i < len; i++)
	{
		printf("%d\n", arr[i]);
	}
}
```

==二维数组遍历==

```C
int arr[][3] = { {1,2,3},{11,22,33},{111,222,333} };

for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }
```

## 应用

### 数组悲波那契数列

含义：前两项都是一，第三项开始每一项都等于前两项之和

```C
#include "stdio.h"

void main()
{
	int a[20]={1,1};
	int i;
	for(i=2;i<=19;i++)
		a[i]=a[i-1]+a[i-2];
	for(i=0;i<20;i++)
	{
		printf("%6d",a[i]);
		if((i+1)%5==0)
			printf("\n");
	}
}
```

* 只有20个数

### 冒泡排序

升序版：从左往右，大的往后冒泡
```C
void main()
{
	int a[10]={10个数}
	int t,flag; //作为交换结束标记
	for(int i=;i<=9;i++)
	{
		flag=0;
		for(int j=0;j<=9-j;j++)
		{
			if(a[j]>a[j+1])
			{
				t=a[j];
				a[j]=a[j+1];
				a[j+1]=t;
			}
		}
		if(flag==0)
			break;
	}
}
```

* flag作用：在遍历了整个数组后发现不需要交换，则flag=0直接break整个外层遍历
* 降序版：从左往右，小的往后冒泡。操作：只需将内层循环的if中>改为<

# 函数

在C语言中调用库函数时应包含对应的头文件，自定义函数则不需要

一个函数由**函数首部**和**函数体**组成，函数体又包含语句部分和声明部分

函数分类：有参函数、无参函数、空函数

* 空函数：函数体为空的函数

使用前提：先定义后调用；声明-调用-定义

函数的递归调用：直接或间接调用自己称为递归调用。分为直接递归和间接递归

* 注意：main函数不能调用自己

函数的实参传递分为**值传递**和**地址传递**：

* 值传递：实参单元仍保留并维持原值，没有改变。实参向形参的数据传递是“值传递”，**单项传递**，只能由实参传给形参，而不能由形参传给实参。**实参和形参在内存中占有不同的存储单元**，实参无法得到形参的值
* 地址传递：函数的参数是数组名或者指针。传递的是数组的首地址或指针的值，而形参接收到的是地址，即指向实参的存储单元，**双向传递**，**形参和实参占用相同的存储单元**，即形参和实参是相同的

函数的调用与结束：调用函数时为其分配存储单元，函数调用结束后释放其存储单元

## 语法

定义语法：
```C
返回值类型 函数名(形参列表)
{
	函数体;
	return 返回值;
}
```

* 定义位置：自定义函数要写在main函数上面，或写main函数下面时先在main函数上面声明定义的函数。声明格式：`返回值类型 函数名(形参列表);`（不写形参列表也可以）
* 在函数的形参中定义的数组可以没有长度
* 省略：当函数返回值为int类型时，可以省略int
* 注意：函数之间是同级的，不能嵌套定义，但可以嵌套调用

实参与形参：实参负责传递，形参负责接收。当实参与形参类型不同时，以形参为准

调用语法：`[接收变量 =] 函数名(实参列表);` #C 

* 函数的递归调用：在调用一个函数的过程中又出现直接或间接地调用该函数本身，称为函数的递归调用

## 常用函数

### stdio.h

全称：Standard Input Output

| 函数                | 功能        |
| ----------------- | --------- |
| printf("占位符",内容)  | 打印语句      |
| scanf(‘格式符“,变量地址) | 键盘录入并赋值变量 |

### math.h

| 函数                     | 功能     | 说明            |
| ---------------------- | ------ | ------------- |
| double pow(num1, num2) | 幂      | 计算num1的num2次幂 |
| double sqrt(num)       | 算术平方根  | 计算num的算术平方根   |
| double ceil(num)       | 上取整    | 对num向上取整      |
| double floor(num)      | 下取整    | 对num向下取整      |
| int abs(num)           | 整型绝对值  | 计算整型num的绝对值   |
| double fabs(num)       | 浮点型绝对值 | 计算浮点型num的绝对值  |

* 特殊：abs函数使用的标头为<stdio.h>

### stdlib.h

| 函数     | 功能    | 说明           |
| ------ | ----- | ------------ |
| rand() | 生成随机数 | 数的范围为0~32767 |

rand()实际应用：生成三位数的随机数
```C
rand()&900+100  //(100.999)
```

### string.h

| 函数                     | 功能       | 说明                                              | 细节                                                   |
| ---------------------- | -------- | ----------------------------------------------- | ---------------------------------------------------- |
| puts(str)              | 打印字符串    | 打印str内容，并返回指向该str的指针                            | 结尾自带换行                                               |
| gets(str)              | 键盘赋值字符串  | 将输入内容赋值到str中，并返回指向该str的指针                       | 相比scanf能够接收带空格的字符串                                   |
| strlen(str)            | 获取字符串长度  | 从左至'\\0'计算字符串内容的长度，并返回长度值(正)                    | 会单独统计转义字符，但不会统计结束标记符'\\0'。`'\032'`时会统计为一个八进制转义字符     |
| strcat(str1,str2)      | 拼接字符串    | 将str2的内容拷贝拼接到str1中                              | str1的长度必须满足总拼接长，复制内容包括str结尾标记                        |
| strcpy(str1,str2)      | 赋值字符串    | 将str2内容拷贝覆盖到str1                                | 是从str1的结尾标记符开始拼接；str1的长度必须足够拷贝                       |
| strncpy(str1,str2,num) | 覆盖个数特定内容 | 将str2中的num个覆盖到str1中的前num个内容                     |                                                      |
| int strcmp(str1,str2)  | 比较字符串内容  | 自左向右逐个比较字符ASCII码值；如果相等返回0，如果str1>str2返回1，小于返回-1 | 包括大小写比较；相同返回0；不同处第一个字符str1>str2返回正整数，str2\<str1返回负整数 |
| \_strlwr(str)          | 内容转成小写   | 将内容中的大写字母变成小写                                   |                                                      |
| \_struper(str)         | 内容转成大写   | 将内容中的小写字母变成大写                                   |                                                      |

# 指针

## 语法
 
指针：就是地址，16位编译器占用2个字节，32位占用4个字节，64位占用8个字节

指针变量：存储内存地址(首地址)的变量，指向变量，所占用空间大小与存储的数据类型大小相同

指针变量定义：`数据类型 *指针变量名, *指针变量名...;`

指针变量赋值：`指针变量名 = &变量名;`

通过指针赋予/更改数据：`*指针变量名 = 值;`

输出指针变量值：`printf("格式化字符串",*指针变量名);`

输入赋值指针变量值：`scanf("格式化字符串字符串", &变量);`

* 定义：只定义时指向了一个随机的内存的地址，是野指针，为安全通常要NULL初始化
* 注意：定义的指针类型应该与存储内存的变量类型一样

两个重要符号：&和\*

* &取地址运算符：&a 是变量a的地址
* \*指针运算符：\*p代表指针变量p指向的对象

## 指针作用(作为函数参数和引用字符串)

当函数的形参为指针时，此时传递方式为**地址传递**，实参可以被改变

==作用 1：通过调用函数形参指针，操作实参变量==

问题：当调用函数时传入的实参只能起到值传递作用，不能将实参本身传递，从而对实参进行操作

解决：将函数形参定义为指针，调用函数时传入变量地址，通过地址间接操作实参

==作用2：返回多个函数值==

问题：每一个函数只能return一个值，无法返回多个值

解决：设定两个指针类型变量形参作为函数返回值，当需要调用函数时，将该两个实参利用指针修改作为返回值

==引用字符串==

定义：`char *指针变量名(字符串名) = "内容";` #C 

使用与输出：直接将指针变量名当字符串名使用，不需要解引用

* 字符串指针变量名本质：存储字符数组(字符串)的第一个字符的地址
* 注意：不能通过数组修改某个字符串中的字符。如：`p[2] = 'a';`，但可以通过修改p指向的地址从而修改整个内容

## 指针运算(步长)

步长：一个步长相当于指针移动一次，至于走了多少字节，与所指向的类型有关(变量、数组、地址)

一维数组中的步长：在一维数组中，指针存储的是列元素的地址，p+1表示走向下一个元素的地址，p-1表示走向上一个元素的地址，每次走一个列元素字节数

二维数组中的步长：在二维数组中，指针存储的是行元素的地址，p+1表示走向下一行的地址，p-1表示走向上一个行的地址，每次走一个行元素字节数

总结：在步长的字节计算中，**走一步是相对于指针当前指向谁而言的**。指针指向变量则走一个数据类型变量字节数；指针指向数组则走数组个数据类型变量字节数；指针指向地址(无论变量还是数组)则走一个操作系统位数字节数

注意：指针可以单个进行增减，但两个指针之间只能进行互减，此时结果表示该两指针的间隔步长

## 其它指针类型

==void* 指针==

void\*为空类型或无类型指针，指向空类型或不确定类型的数据

特性：void* 类型指针可以与任意类型指针相互转换(隐式转换即可)，但不能通过该指针获取内存地址中的数据和指针运算

注意：定义时指向的是不确定类型数据，赋值后指向了确定类型数据，但自身并没有类型信息(数据有类型指针没类型)

 应用：作为函数形参接收任意类型指针
```C
# 函数功能：交换指定长度的两个变量值
void swap(void *p1, void *p2, int len)
{
	// 把void类型的指针，转成char类型指针
	char *pc1 = p1;
	char *pc2 = p2;

	char tmp = 0;

	// 以字节为单位，一个字节一个字节进行交换
	for (int i = 0; i < len; i++)
	{
		tmp = *pc1;
		*pc1 = *pc2;
		*pc2 = tmp;

		pc1++;
		pc2++;
	}
}
```

* 通过void* 类型指针获取数据方法：将void类型指针转换为其它类型指针利用即可

NULL空指针：不指向任何有效内存地址，用于指针变量初始化，指针变量值为NULL(整数形式为0)，用于判断(与"NULL"和0)不用于打印

## 数组与指针

### 语法

知识前提：数组名的本质是一个地址

**数组名退化：数组名直接使用是会退化为指向该数组中首元素的指针。一维数组中首元素为变量，为指向变量的指针；二维数组中首元素为一维数组，为指向整个一维数组的指针**。如果没有退化则会表示整个数组地址

没有退化情况：作为`sizeof` 运算符的操作数和地址运算符 `&` 的操作数

==数组元素的指针变量==

含义：存储了数组中元素地址的指针变量，指向变量，本质还是一个存储变量地址的指针变量

实例：
```C
int arr[] = { 1,2,3,4,5,6,7,8 };
int *p = arr;
```

* 步长：指向变量，一步长为一个变量长
* 数组名发生了退化

数组引用：`a[i]`（下标法）或 `*(a+i)`（指针法）

**理解**：a先退化为第一个元素的地址，然后偏移i步长到新地址，最后对地址解引用。**总共三阶段：退化、偏移、解引用**

==数组指针==

含义：存储了整个数组地址的指针变量，指向整个数组，本质是一个存储了整个数组地址的指针变量

初始化：`数据类型 (*指针变量名)[数组长度] = 数组地址;` #C 

* 步长：存储的是一个数组的地址，一步为一个数组的大小

```C
int arr[5] = { 1,2,3,4,5 };
int (*p)[5] = &arr;
```

* p等同于&arr，存储整个数组地址，指向整个数组；\*p等同于arr，存储了&arr[0]地址，指向a[0]

(数组)数组指针使用注意点：\*数组指针为数组名使用方式，存储的是首元素地址，指向首元素

==指针数组==

含义：存储了多个元素为指针的数组，本质是一个数组

初始化：`数据类型 *数组名[长度] = {值1,值2,...};` #C 

* 步长：数组名指向的是一个地址，大小与操作系统有关

作用：存储若干个字符串。例：`char *strs[4] = {"abcd", "efgh", "ijkl", ...};`

(记忆 )区分定义数组指针与指针数组：符号结合优先级：`( ) > [ ] > *`，哪个先结合本质就是谁，且命名时在后面

### 指针在数组中的作用

#### 访问元素

通过数组指针访问数组元素
```C
# 通过指针运算获取第二个索引值
int arr[] = { 1,2,3,4,5,6,7,8 };
int *p = arr;
printf("%d", *(p + 1));
```

#### 数组中的指针作为函数参数

| 实现  | void test(int arr[] ,int sz){} | void test(int *arr ,int sz){} |
| --- | ------------------------------ | ----------------------------- |
| 调用  | test(&arr,sz);                 | test(arr,sz);                 |

* 区别：都是使用指针作为形参，但前一个`int arr[]`是将整个数组地址作为地址传递，而后一个`int *arr`是将数组中首元素地址作为地址传递

#### 指针遍历数组

##### 一维数组遍历

方法一：指针变量
```C
int arr[] = { 10,20,30,40,50 };
int len = sizeof(arr) / sizeof(int);
int *p = arr;

for (int i = 0; i < len; i++)
{
	printf("%d\n", *p++);
}
```

方法二：数组指针
```C
int arr[] = { 10,20,30,40,50 };
int len = sizeof(arr) / sizeof(int);
int (*p)[len] = &arr;

for (int i = 0; i < len; i++)
{
	printf("%d\n", (*p)[i]);
}
```

注意：\*和++、--符号为同级运算符，但执行顺序是从右向左。例：`*++p`，为先++p后*

##### 二维数组遍历

在二维数组中，不同表达形式的语句具有不同含义，但所指向的地址值可能相同

例：`int a[][4];`，有以下几种不同表达形式（同含义同地址）：

| 表示形式                             | 含义               | 地址   |
| -------------------------------- | ---------------- | ---- |
| a                                | 0行首地址            | 2000 |
| a[0]，\*(a+0)，\*a                 | 0行0列元素地址         | 2000 |
| a+1，&a[1]                        | 1行首地址            | 2016 |
| a[1]，\*(a+1)                     | 1行0列元素a[1][0]的地址 | 2016 |
| a[1]+2，\*(a+1)+2，&a[1][2]        | 1行2列元素a[1][2]的地址 | 2024 |
| \*(a[1]+2)，\*(\*(a+1)+2)，a[1][2] | 1行2列元素a[1][2]的值  | 元素值  |

###### 指针变量

方法：通过取列1元素地址，进行步长遍历
```C
int arr[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };

int *q = &arr[0][0]; //第一种写法
int *q = arr[0]; //第二种写法
for (int i = 0; i < 12; i++)
{
	printf("%d\n", *(q + i));
}
```

* 第二种写法：arr先退化为指向整个一维数组地址，然后0步长获取第一个一维数组地址，最后\*解引用获取一维数组名，再退化为指向0列元素的指针

###### 数组指针

方法：通过一维数组的指针遍历
```C
int arr[3][5] = { {1,2,3,4,5},{11,22,33,44,55},{111,222,333,444,555} };
int (*p)[5] = arr;

for (int i = 0; i < 3; i++)
{
    for (int j = 0; j < 5; j++)
    {
        printf("%d ", *(*p+j));
    }
    printf("\n");
    p++;
}
```

* `*(*p+j)`理解：先`*p`获得一维数组，此时会退化为指向列0元素的指针，然后偏移j步长到新地址，最后\*解引用获得变量值

###### 指针数组

```C
int arr1[] = {1,2,3};
int arr2[] = {1,2,3,4,5};
int arr3[] = {1,2,3,4,5,6,7,8,9};

int len1 = sizeof(arr1) / sizeof(int);
int len2 = sizeof(arr2) / sizeof(int);
int len3 = sizeof(arr3) / sizeof(int);
int lenArr[] = {len1,len2,len3};

int *arr[3] = { arr1,arr2,arr3 };
for (int i = 0; i < 3; i++)
{
    for (int j = 0; j < lenArr[i]; j++)
    {
        printf("%d ", arr[i][j]);
        // printf("%d ", *(arr[i]+j ));
    }
    printf("\n");
}
```

* `arr[i][j]`理解：arr先退化为指向列0元素(新数组)的指针，然后偏移i步长到新地址，之后\*解引用获得新元素(数组)，新数组退化为指向首元素的指针，然后偏移j步长，最后\*解引用获得变量值

## 函数与指针

知识前提：函数名本身也是个地址

==函数指针==

含义：是一个存储了函数地址的指针变量，指向函数

函数指针变量定义：`返回值类型 (*指针变量名)(形参数据类型)`； #C 

* 返回值类型：应与指向函数的返回值类型一致
* 形参数据类型：与函数形参列表中的数据类型一致，但可以不用写定义变量名

初始化：`返回值类型 (*指针变量名)(形参列表/数据类型) = 函数地址;` #C 

* 函数地址：可以是直接的`函数名`(推荐)，也可以是`&函数名`

调用：`[返回值赋值 =] 函数指针变量名(实参1, 实参2...);` #C 

* 使用：可以直接像普通函数调用一样(推荐)，也可以在调用前先`*函数名`

注意：函数指针的运算无任何意义

实例：
```C
void main()
{
	// 定义并初始化函数指针
    int (*q)(int, int) = sum;

    // 调用函数指针
    int res = q(1,2);

}

int sum(int num1, int num2)
{
    return (num1 + num2);
}
```

==指针函数==

含义：指的是函数的返回值是一个指针

# 自定义数据类型

## typedef声明新类型名

无符号int：`typedef unsigned int newname;`

数组：`typedef int newname[10];`

指针：`typedef int* p;`

函数指针：`typedef (*newname)(int,int);`

结构体：
```c
typedef struct S
{
	成员表列;
}newname;
```

总结定义格式：由原来定义变量时的格式前加typedef，则定义的变量名就改为新类型名

## 结构体类型struct

结构体（struct）是一种聚合数据类型，用于将多个不同类型的变量组合在一起

结构体成员：每一个结构体中定义的变量都是结构体的一个成员

结构体变量：采用结构体类型创建的变量

==语法==

声明结构体类型：
```C
struct 结构体名
{
	成员表列;
};
```

* 结构体成员声明格式`类型名 成员名`（与变量定义相同），不需要赋值
* 结构体名又称类型名，与struct共称为结构体类型名

定义结构体变量：`struct 结构体名 结构体变量名;`

声明并定义：
```C
struct 结构体名
{
	成员表列;
} 结构体变量1, ...;
```

只定义结构体变量：
```C
struct
{
	成员表列;
} 结构体变量1, ...;
```

配合typedef：
```C
struct 结构体名
{
	成员表列;
} 别名;
```

声明结构体变量并初始化：
```C
struct data
{
	int a;
	float b;
} s = {1,1.22};
```

声明结构体数组并初始化：
```C
struct data
{
	int a;
	float b;
} C[3] = {1,2,3,4,5,6};
```

* 说明：C[3]看做是三个结构体变量构成的结构体数组，分别有C[0]、C[1]、C[2]三个结构体变量，其中结构体变量的成员值分别为 C[0]:1和2、C[1]:3和4、C[2]:5和6

(顺序)初始化：`struct 结构体名 结构体变量名 = {成员值1,成员值2...};`

(自定义顺序)初始化：`struct 结构体名 结构体变量名 = {.成员1 = 成员值1, .成员2 = 成员值2,...}`

* 将(struct 结构体名)当作整体(一种数据类型)使用

==结构体成员引用==

形式一：`结构体变量名.成员名`

形式二：`结构体指针名->成员名`

形式三：`(*结构体指针名).成员名`

* 说明：(.)为成员运算符；(->)为指向运算符
* 注意：形式三的括号不能丢弃

## 共用体/联合体union

声明：
```C
union 共用体类型名
{
	成员表列;
}
```

定义与其它操作(引用成员)与结构体相同

共用体所占用的存储空间为最大成员所占存储空间

当多次对共用体成员赋值时，共用体只能存放最后一次存入的成员的值

# 读写文件

数据可以用**二进制**和**ASCII**两种代码形式存放

二进制文件：如果不加转换地输出到外存，就是二进制文件，可以认为它就是存储在内存的数据的映像，所以也称之为映像文件(image file)

ASCII文件：在外存中以ASCII码形式存储，需要在存储前进行转换，每一个字节放一个字符的ASCII代码，ASCII文件又称文本文件

无论哪种形式，数据在内存中最终是以二进制形式存储的

==顺序读写==

文件指针定义：`File *文件指针名;` #C 

| 返回值   | 函数                              | 功能           | 说明                                                                      |
| ----- | ------------------------------- | ------------ | ----------------------------------------------------------------------- |
| FILE* | fopen("文件路径","使用方式")            | 打开文件并赋予文件权限  | 返回一个该文件的指针，如果r、a模式下文件不存在则报错返回NULL空指针                                    |
| int   | fclose(FILE*)                   | 关闭文件         | 使文件指针不在指向文件；执行成功返回0，失败返回EOF(-1)                                         |
| int   | fgetc(FILE\*)                   | 读取一个字符       | 一次读取一个字符，读取成功返回读取字符，读取失败返回EOF(-1)                                       |
| int   | fputc(字符,FILE*)                 | 写入字符         | 一次写入一个字符，输出成功返回输出字符，输出失败返回EOF(-1)                                       |
| char* | fgets(数组,内容大小,FILE\*)           | 读取一行内容       | 一次读取一行内容('\\n'识别)，读取内容到赋给数组(最后加'\\0')，然后读取指向下一行，并返回该数组的指针，读取失败返回NULL空指针 |
| int   | fputs(字符串,FILE*)                | 写入一个字符串      | 一次写入一个字符串(不包括末尾'\\0'，不会换行)，成功写入返回0，写入错误则返回非0值                           |
|       | fprintf(FILE*,占位符,变量)           | printf方法写入数据 | 后两个参数同printf参数一样，将原printf打印的内容写入文件                                      |
|       | fscanf(FILE*,格式符,&变量)           | scanf方法读取数据  | 后两个参数同scanf参数一样，将文件数据录入变量中                                              |
| int   | fread(字节数组,每次读取字节数,读取次数,FILE*)  | 二级制格式读取字节数组  | 总共读取每次数×一次数字节，将读取的内容赋值给数组地址指向数组，读取成功返回读取次数，失败返回0                        |
| int   | fwrite(字节数组,每次写入字节数,写入次数,FILE*) | 二级制格式写入多个内容  | 将字节数组中内容按每次写入字节数多次写入，写入成功返回写入次数，失败返回0                                   |

* EOF含义是指文件结束标志
* 前四种读写仅用于文本文件，当读写二进制文件时需要添加b
* 字节数组与字符数组定义相同，使用char即可

| 使用文件方式 | 说明          |
| ------ | ----------- |
| "r"    | 只读模式        |
| "w"    | 覆盖写入模式      |
| "a"    | 追加写入模式      |
| "rb"   | 只读模式(二进制)   |
| "wb"   | 覆盖写入模式(二进制) |
| "ab"   | 追加写入模式(二进制) |

* 记忆：r-读、w-写、a-追加、+-读写、b-二进制文件
* 当有w时，如果文件不存在则会创建文件

==随机读写==

文件位置标记：读写时会指向下一个字符位置

| 函数                      | 功能     | 说明                                       |
| ----------------------- | ------ | ---------------------------------------- |
| rewind(FILE* )          | 标记指向开头 |                                          |
| fseek(FILE*,位移量(L),起始点) | 改变标记位置 | 位移量是相对于起始点而言的，起始点0表示文件开头，1表示当前位置，2表示文件末尾 |
| long ftell(FILE*)       | 测定标记位置 | 成功指向返回相当于文件开头位移量的值，失败返回-1L               |

==文件出错检测==

| 函数              | 功能                   | 说明           |
| --------------- | -------------------- | ------------ |
| feof(FILE*)     | 检测当前标记位置是否为文件结尾      | 是则返回1，不是返回0  |
| ferror(FILE*)   | 检测fopen返回的指针是否发生错误标志 | 是则返回非零，不是返回0 |
| clearerr(FILE*) | 置错误标志和文件结尾标志为0       |              |

实例：拷贝文件
```C
FILE* file1 = fopen("读取文件路径");
FILE* file2 = fopen("写入文件路径");

char arr[1024];
int n;
while ((n = fread(arr, 1, 1024, file1) != 0))
{
	fwrite(arr, 1, 1024, file2);
}

fclose(file1);
fclose(file2);
```

