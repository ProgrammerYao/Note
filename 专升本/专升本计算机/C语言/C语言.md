
## C语言的特点

1. C语言**简洁、紧凑**，压缩了一切不必要的成份
2. C语言**运算丰富**，将括号、赋值、强制类型转换、取变量地址等都以运算实现
3. C语言**数据类型丰富**，具有现代语言的各种数据类型；用户能扩充数据类型，能够实现各种复杂的数据结构，完成各种问题的数据描述
4. C语言是一种**结构化程序设计语言**，具有结构化语言所要求的三种基本结构(顺序、选择 循环)
5. C语言是**高级语言中的低级语言**。C语言**允许直接访问物理地址**，能进行位运算，能实现汇编语言的大部分功能，能直接对硬件进行操作
6. C语言提供**编译预处理机制**，有利于大程序的编写和调试
7. C语言编译系统小，生成的目标代码质量高，程序的**执行效率高**
8. C语言的输入和输出功能用库函数实现，编写的程序**移植性好**，能够在**不同操作系统**下运行
9. C语言**语法限制不太严格**，程序设计自由度大，对程序员要求较高

：具有兼容性和移植性特点，其中移植性表现能够在不同操作系统下运行

# 前置知识

## 进制转换

==介绍==

进制：二进制、八进制、十进制、十六进制

* 八进制数范围：0~7
* 十六进制数范围：0~9和A~F/a~f

进制脚标：二级制—B 或 $(\ )_2$，八进制—Q 或 $(\ )_8$，十进制—D 或 $(\ )_{10}$，十六进制—H 或 $(\ )_{16}$

* 十进制数脚标可省略
* 记忆：BBQdh

==转换==

非十转换为十：按权展开，个位为0次方，负数后第一位为-1次方

十转非十：整数部分—短除法(转几除几，除至商为0)，结果倒取余数；小数部分—转几乘几，每次取整数部分，直至小数部分为0，结果为正摆所有整数部分

二进制、八进制、十六进制互相转换：

* 3位二进制转1位八进制，4位二进制转1位十六进制，整数部分不足前补0，小数部分不足后补0
* 反之1位八进制转3位二进制；1位十六进制转4位二进制
* 注意：转换为八进制数或十六进制数时需要0或0x符前导

实例：$(52.2)_8=(\ )_{10}$ (八转十)

* 解析：$整数：5×8^1+2×8^0=42;小数=2×8^{-1}=0.25;结果=42.25$

实例：$(5.625)_{10} = ()_2$(十转非十)

* 解析：
	* 整数：
		* $5 ÷ 2 = 2$ 余 1
		- $2 ÷ 2 = 1$ 余 0
		- $1 ÷ 2 = 0$ 余 1
		- 倒取余数为101
	- 小数：
		- $0.625 × 2 = 1.25$，取整数部分 1
		- $0.25 × 2 = 0.5$，取整数部分 0
		- $0.5 × 2 = 1.0$，取整数部分 1
		- 顺序摆放为101
	- 结果：101.101

实例：$0x2F=()_2$(十六转二)

* 解析：
	* 2=0010
	* F=1111
	* 结果为00101111

不同进制数的加减法：先化简为同进制，然后对位相加减即可

## 原、反、补码

有符号数(正数负数)在计算机中有三种表示方法：即原码、反码和补码，存储时使用补码，表示方法使用8位(1字节)二进制数表示；无符号数只有正数值，只用原码表示和存储

* 原码：8位二级制表示(最左边一位为符号位0正1负，其余为数值位)
* 正数的原、反、补码相同
* 负数：
	* 反码：将数值位逐个取反
	* 补码：在反码的基础上+1
	* 补码求原码：-1再取反(逆运算)

实例：计算 -5 的补码

* 原码：1000 0101
* 反码：1111 1010
* 补码：1111 1011

实例(无符号打印)：`int a = -1; printf("%u",a);`(十六位存储)

* 存储形式：补码1111111111111111
* 无符号打印：全部视为数值位作为原码输出
* 转十进制结果：$=2^{15}+2^{14}+2^{13}...+2^0=2^{16}-1=65535$

## 位运算

位运算是对整数的二进制(补码)表示直接进行操作的运算

| 运算符 | 含义   | 运算规则        | 例子                                         |
| --- | ---- | ----------- | ------------------------------------------ |
| &   | 按位与  | 有0为0，全1为1   |                                            |
| \|  | 按位或  | 有1为1，全0为0   |                                            |
| ^   | 按位异或 | 相同为0，不同为1   |                                            |
| ~   | 取反   | 0取反为1，1取反为0 |                                            |
| <<  | 左移   | 左去N位，右补N个0  | `a = 3(0000 0011)`<br>`a<<2=12(0000 1100)` |
| >>  | 右移   | 右去N位，左补N个0  |                                            |

* 优先级：~、<<、>>、&、^、|
* 左右移理解：左移后面补0变大了，右移前面补0变小了

计算：由于是对二进制进行运算，故计算其它进制数时需先转换为二进制，并且是对补码进行运算

* 注意：由于是对补码操作，故需要区分负数的补码，十进制数操作前需要先转换为补码
* 例子：~4
	* 转换为补码：0000 0100
	* ~取反：1111 1011
	* 转换为原码：1000 0101
	* 十进制结果为-5

十进制计算规则：

* 十进制数取反规则：$~a=-(a+1)$
* 正数十进制左右移计算规则：左移N位相当于$×2^{N}$，右移N位相当于$÷2^{N}$

复合位运算：&=、|=、^=、<<=、>>=

位运算特点：

| 运算符 | 0      | 1   |
| --- | ------ | --- |
| &   | 清0(变0) | 不变  |
| \|  | 不变     | 置1  |
| ^   | 不变     | 求反  |

* 记忆主要功能：清0、置1、求反
* 实例：
```
能将1字节变量x的高4为全置成1，低4位字节保持不变的表达式是  x|11110000

能将1字节变量x的高4为保持不变，低4位清0的表达式是  x&11110000
```

# 程序设计语言

### 概述

**程序 = 算法 + 数据结构**

算法：可以看作是由**有限个步骤组成的用来解决问题的具体过程**。算法有三种基本结构，分别是**顺序结构、选择结构和循环结构**

数据结构：是从问题中抽象出来的数据之间的关系，它代表信息的一种组织方式。反映一个数据的内部结构，其目的是提高算法的效率，它通常与一组算法的集合相对应，通过这组算法集合可以对数据结构中的数据进行某种操作。典型的数据结构包括线性表、堆栈和队列

程序：对问题的**具体代码实现**

计算机语言分类：**机器语言、汇编语言、高级语言**（**机器语言和汇编语言统称为低级语言**)

机器语言：**是机器能直接识别的程序语言或指令代码**，它直接由**0或1**这样的二进制数值进行编码。从系统结构的角度看，它是系统程序员看到的计算机的主要属性。指令系统表征了计算机的基本功能同时也决定了机器所能被要求的能力，也决定了指令的格式和机器的结构。机器语言由于可以被计算机直接识别并执行，所以它的执行效率很高，但是因为它是基于计算机指令系统的程序语言，所以可移植性很差

汇编语言：采用一定的**助记符**来代替机器语言中的指令和数据，又称为符号语言。汇编语言一定程度上克服了机器语言难读难改的缺点，同时保持了其编程质量高、所占存储空间小、运行速度快的优点。故在程序设计中，对实时性要求较高的地方，如过程控制等，仍经常采用汇编语言，该语言也依赖于机器，不同的计算机一般也有着不同的汇编语言

用高级语言编写的程序易学、易读、易修改、通用性好，**不依赖于机器**，但**机器不能对其编制的程序直接运行**，必须经过语言处理程序的翻译后才可以被机器接受。高级语言的种类繁多，如面向过程的Fortran、Pascal、**C**等，面向对象的C++、Java、Visual BASIC等

### 语言处理程序

针对不同的程序设计语言编写出的程序，它们有各自的翻译程序，互相不通用

==汇编程序==

汇编程序是将汇编语言编制的程序(源程序)翻译成机器语言程序(目标程序)的工具。将汇编语言源程序转换为等价的目标程序的过程称为汇编

==高级语言翻译程序==

高级语言翻译程序是将高级语言编写的源程序翻译成目标程序的工具。**翻译程序有两种**工作方式：**解释方式和编译方式**。相应的翻译工具也分别称为解释程序和编译程序

解释：解释程序是对源程序**一边翻译、一边执行，不产生目标程序**。解释程序对源程序进行逐句分析，若没有错误，将该语句翻译成一个或多个机器语言指令，然后立即执行这些指令;若当它解释时发现错误，会立即停止，报错并提醒用户更正代码。早期的BASIC语言采用解释方式

编译：将高级语言所编写的**源程序翻译成机器语言表示的目标程序**。源程序经过编译处理，会产生一个与源程序等价的目标程序，但目标程序还不能直接执行，通过**链接**程序将目标程序和有关的程序库组合成完整程序**后才可以执行**。最终产生的可执行程序可以脱离编译程序和源程序独立存在并反复使用，大多数高级语言都是采用编译方式

==C语言编译过程==

![[Pasted image 20240904185811.png]]

**过程**：编辑 -> 源程序(.c文本文件) - 编译 ->目标文件(.obj二进制文件) - 链接 -> 可执行文件(.exe二进制文件) - 执行

* **其中源程序，目标程序不能被计算机直接执行，只有可执行文件能够被直接执行**

**C程序可以由多个程序文件组成**

一个源程序文件中包括3个部分：**预处理指令、全局声明和函数定义**

结构化程序设计方法的主要原则有：**模块化、自顶向下、逐步求精**

## C程序结构和基本语法成份

==C程序结构==

```C
# include <stdio.h>

int main() //函数头
{

	return 0;
} //函数体

// 单行注释

/*
	多行注释
*/
```

函数：C语言程序由若干函数组成，**函数是C程序的基本单位**。**必须有且只有一个主函数main()**，该函数是**程序的入口和出口**。**函数之间是平行关系**

语句：**语句是组成程序的最小单位**。**C语言本身没有输入/输出语句**，C语言的输入/输出操作由scan函数和printf函数等库函数完成。语句**必须以分号结束**。只有分号构成的语句叫**空语句**，也被编译执行。一行可写一条或多条语句，一条语句也可写成一行或多行

# 核心语法

## 注释

在C语言中，对**编译和运行不起作用**的是**注释**

单行注释：`//内容`

多行注释：`/* 内容 */`

## 标识符

标识符由**数字**(0~9)、**字母**(a~z,A~Z)、**下划线**组成，并且**首字母不能是数字**。**字母区分大小写**

标识符分类：**关键字、预定义标识符、用户标识符**

关键字：32个，均为小写![[Pasted image 20241016212301.png]]

预定义标识符：C语言中系统预先定义的标识符，如函数库中的函数名、宏定义和类型别名。如：define、scanf、printf、include

用户标识符：用户根据需要自己定义的标识符。一般用来给变量、函数、数组等命名。**关键字不能作为用户标识符**

## 常量、变量与常变量

### 常量

含义：在运行程序过程中，其值不能被改变的量称为常量

分类：整型常量、浮点(实)型常量、字符型常量、字符串常量、符号常量

整型常量表示：**八进制**用前导0，**十六进制**用0x或0X表示

实型常量表示：

* 十进制数形式：必须有小数点，至少一边是数字
* 科学计数法：e前e后都有数，e后必须为整数，e后还能带符号，e/E均可

字符常量：

* 单引号(' ')括起的 单个普通字符 或 转义字符
	* 常用ASCII码：'A'-65，'a'-97，'0'-48，'\0'-0（大写+32=小写）（字符数字-48=int数字）
	* 注意：字符参与运算是根据ASCLL值计算的。例：`'0'`计算时为48，而`0`计算时为0
* 字符的计算：将字符转换为对应ASCLL计算后，再将ASCLL转换回字符比较好计算
* 重要转义字符：

| 转义字符    | 含义                   | 注意                    | 例子                           |
| ------- | -------------------- | --------------------- | ---------------------------- |
| '\\n'   | 回车换行                 |                       |                              |
| '\\t'   | 横向跳格，该制表符会占用4个空格位置   |                       |                              |
| '\\b'   | 退格                   | 退格后会覆盖内容，一个新字母只覆盖一个旧的 | `printf("abc\b\bXY"); //aXY` |
| '\\\\'  | 反斜杠                  |                       |                              |
| '\\''   | 单引号                  |                       |                              |
| '\\"'   | 双引号                  |                       |                              |
| '\ddd'  | 1至3位八进制表示的1个字符的ASCLL | 最多使用三位表示八进制           | `'\101'='A'`                 |
| '\\xhh' | 1至2位十六进制表示的1个字符ASCLL | 最多使用两位表示十六进制          |                              |

字符串常量：

* 由双引号(" ")括起，双引号中可以没有内容，每个字符串结尾都有隐藏的'\\0'表示字符串的结束，占1个字节
* 注意：字符串常量中每个字符都可以看做一个字符常量，故需注意多位计1位的转义字符
* 实例：`printf("%d",sizeof("he\129llo")); //8`，其中'\\12'，'9'，'\\0'各计一位
* 区分字符常量和字符串常量：分别由单引号和双引号括起，其中字符常量只能为一个字符

符号常量定义：`#define 变量名 值;`

* 在预编译时处理，作简单的字符串替换

### 变量

含义：指在程序运行过程中其值可以改变的量，可以在程序运行过程中给它们赋予新的值

类别：分为**局部变量**和**全局变量**，并且有不同的数据类型和存储类别

全局变量和static变量 定义时就有初始值为零；局部变量定义时没有初始值

使用前提：变量必须先定义后才能被使用

#### 语法

定义：`类型 变量名1 [, 变量名2, ...];`

* 定义位置：当定义在函数内为局部变量，函数外时为全局变量

赋值：`变量名 = 常量;`

初始化：`类型 变量名 = 常量;`

多个同类型初始化：`数据类型 变量名1 = 数据值1[, 变量名2 = 值2];`

#### 变量属性(作用域、存储类、生存期)

##### 作用域

局部变量：在函数内部定义的变量，包括形参

作用域：从(函数内或复合语句内)定义的位置到复合语句或函数的结束

全局变量：在函数的外部定义的变量

作用域：从定义的位置到整个程序结束

注意：在同一作用域的两个同名变量，使用遵循最近原则。被调用函数中的就近为调用处开始往上

##### 存储类别

存储类别有四种：auto(自动的)、static(静态的)、register(寄存器的)、extern(外部的)

* 其中auto为变量默认存储类别
* 变量和函数共有两个属性：数据类型和数据的存储类别

基本语法：`存储类别 数据类型 变量名;`

`auto`自动变量：函数中的**局部变量**默认都是动态分配存储空间的，在调用该函数时系统会给这些变量分配存储空间，函数调用结束时就自动释放存储空间。

* 不能用于全局变量

`static`静态局部变量：函数中的局部变量的值在函数调用结束后不消失而保留原值，即其占用的存储单元不释放，在下一次再调用该函数时，该变量已有值。

* 内部变量：仅允许当前文件使用
* 注意：静态变量的初始化只有第一次生效，但可以多次重新复制

`register`寄存器变量：将定义的**局部变量**放在CPU的寄存器中，也是调用函数后释放

* 作用对象：局部变量

存储：自动变量存储在动态存储区；静态局部变量存储在静态存储区；寄存器变量存储在寄存器。

`extern`外部变量：文件定义了全局变量，那么在另一文件中`extern`声明后便可以在该文件使用该变量，声明格式`extern 数据类型 变量名;`。定义函数时默认使用了extern修饰，此时其它文件可以直接使用该函数不需要声明

##### 生存期(生存周期)

根据变量的生存期来辨别存储方式分为两种：静态存储方式和动态存储方式(寄存器另计)

静态存储方式：指在程序运行期间由系统分配固定的存储空间的方式，直到整个程序结束

动态存储方式：指在程序运行期间根据需要进行动态的分配存储空间的方式，函数调用时临时分配内存，函数结束时释放

### 常变量

常变量：具有数据类型和名字的常量

定义：`const 数据类型 常变量名;`

定义并赋值：`const 数据类型 常变量名 = 值;`

特点：不能更改其值和数据类型

## 数据类型

### 介绍

C语言中三种基本数据类型：**整型**、**实型**、**字符型**

==整型==

| 关键字              | 类型   | 占用字节                                            | 后缀     |
| ---------------- | ---- | ----------------------------------------------- | ------ |
| int              | 基本型  | TurboC占2个字节(16位编译器)<br>VC++系统下占**4个字节**(32为编译器) |        |
| short(short int) | 短整型  |                                                 |        |
| long(long int)   | 长整型  |                                                 | 必须要l或L |
| unsigned         | 无符号型 |                                                 |        |

* 无符号型变量定义：`signed/unsignde 数据类型 变量名;`

==实型==

| 关键字         | 类型                    | 占用字节 |
| ----------- | --------------------- | ---- |
| float       | 单精度浮点型(float型)        | 4个字节 |
| double      | 双精度浮点型(double型)       | 8个字节 |
| long double | 长双精度浮点型(long double型) |      |

==字符型==

| 数据类型 | 字节数 |
| ---- | --- |
| char | 1   |

* char类型既能表示字节也能表示字符，因为字符本质就是一个字节。当为`''`赋值时为字符，直接的数值赋值为字节，中文不能赋值给字符，因为2或3个字节内容不能赋值给1字节的char，中文要用字符数组

存储：在内存中是以其对应的 **ASCII** 编码值存储的

==其它==

空类型-void

### 数据类型转换

整型和字符型可以相互转换

示例：
```c
printf("%d", 'a');  //97
printf("%c", 97);  //a
```

#### 隐式转换

触发条件：当进行不同数据类型的运算时，最终结果为占用字节最多的数据类型

* 运算前，char和short类型会直接先提升为int，然后再进行运算
* 注意：只有遇到了高类型才会转换，没遇到前不会转换。例：`3.2+5/2=5.2`

#### 强制转换

使用条件：如果把取值范围大的，赋值给取值范围小的，就需要进行强制转换

转换语法：`数据类型 变量 = (转换类型)变量;`

注意：将小的转换为大的数据不会变化，但将大的转换为小的数据可能出问题。原因：大字节数据会丢掉前面部分字节使其变为小字节数据

比较：`(int)(a+b)`和`(int)a+b`

* 前是把 a+b 转型，后是把 a 转型再加 b

题型：数学公式转换

* 数学符号与函数：
	* 根号：`sqrt(num)`。例：`sqrt(b*b-4ac)`表示$\sqrt{(b^2-4ac)}$
	* 幂：`pow(num1, num2)`。例：`pow(x,2)`表示$x^2$
	* 绝对值：`abs(num)`。例：`abs(x)`表示$|x|$
	* 三角函数？
* 注意：
	* C表达式乘法时不能省略`*`
	* C表达式只有小括号没有中括号
	* 实型除法转换中，在进行第一次计算时就进行实型转换，否则会丢失精度。实型或不确定除法转换时就不需要
		* 实例：$\frac{1}{abc}(a、b、c为整型)$表达式为`1.0/a/b/c`

## 复合语句和空语句

单语句：使用`;`结尾

复合语句：由多个语句用{}括起

* 说明：复合语句在语法上视为一个语句

空语句：`;`

## 基本运算符

C语言中，0表示假，非0表示真（记忆：多个真一个假）

**表达式**中的真假：表达式的数值结果默认为1或 0

* 实例：`pirntf("%d", 1<0<2);  //1`

### 介绍

操作数：运算符的操作对象

运算符分类：单目、双目、三目运算符

![[Pasted image 20240905203824.png|262]]

* 注意：没有$\leq$，只有<=

运算符**优先级**与**结合性**：决定表达式计算顺序的两个因素
![[Pasted image 20240905204251.png|638]]

* 优先级记忆：单目>双目>三目>赋值>==>=>逗号，特记：&>|>&&>||
* 同级结合律特记：带一个=赋值是从右向左运算

带两种用法的符号：

* &：取地址运算符 或 按位与运算
* \*：指针运算 或 乘法运算

### 使用及注意事项

==赋值运算符==

注意：=号前面不能为常量和运算式

==算术运算符==

注意：

* /：都是整型结果为整型，有一实型结果为实型。两个整数相除时结果会舍弃小数部分
* %：要求**前后都为整数**，**结果正负与被除数的相同**
	* 特殊使用：获取某个数的某位数时，先整除到个位再取余10即可获得。例：获取345的十位数为`345/10%10`

实例：判断回文数

* 回文数：从左到右和从右到左排序都一样的数，为奇数个位数
* 实例：三位个：`x/100%10==x%10`；五位个：`x/10000%10 == x%10 && x/1000%10 == x/10%10`

==自增自减运算符==

格式：`++变量`、`变量++`、`--变量`、`变量--`

* 注意：
	* 只能用于变量，不能用于常量(包括符号常量)
	* 多个+号时前一个变量优先结合最多+号。例：`a+++b`为(a++)+b
	* 表达式中前++和加减乘除一起运算(包括赋值表达式)时，优先计算前++的部分；对于后++则是整个表达式都计算完后才自增变量
	* 当询问表达式的值时，如果有后++，则是先计算表达式的值再进行++；打印时则为全部计算完的结果

例子：定义：`double x = 3.4, y = 3.2；`表达式y+=x++的值是

* 答案：6.6
* 注意：问的是y的值，而y并没有++

==逻辑运算符==

格式：`表达式1 运算符 表达式2;`

* 结果：为真返回1，否则返回0
* 短路效果：&&前面确定为假则后面不执行；||前面为真则后面不执行

==条件运算符==

格式：`表达式 ? 值1 : 值2;`

* 说明：表达式为真返回值1，否则返回值2，多个符号从左算到右

实例：转换大小写

* 转大写：`ch = ch > 'A' && ch < 'Z'? ch : ch-32`
* 转小写：`ch = ch > 'A' && ch < 'Z'? ch-32 : ch`

==逗号运算符==

格式：`(表达式1,表达式2,……,表达式n)`

* 说明：自左向右顺序执行，将最后表达式n的值作为整个表达式的值
* 注意：没有括号时逗号为分隔符，每个逗号都视为一个语句单独执行
* 区别：`int z;z=2,3,4; //2`和`z=(2,3,4) //4`

==求字节运算符==

格式：`pirntf("%zu",sizeof(数据类型/变量));`

* 使用：会统计字符数组结尾`'\0'`为一个字节

## 输入和输出函数

C语言本身没有输入输出语句，需要调用标准库函数来完成，引入头文件"stdio.h“，格式为`# include <stdio.h>`

### printf格式输出函数

基本语法：`printf("格式化字符串", 输出表列)`

* `输出表列`：可以是变量，也可以是常量
* 特殊：纯输出字符串可以直接 `printf("内容")` 表示
* 换行：可以在格式化字符串末尾加\\n；或者可直接使用独立语句`printf("\n");`
* 字符和字符串输出：输出时不会含有(' ')或(" ")
* 注意：当输出表列中数量大于所使用格式说明符时，多余的输出不用理会

普通输出：

| 格式说明符   | 作用                 |
| ------- | ------------------ |
| %d      | 输出有符号整数            |
| %u      | 输出无符号十进制整数         |
| %c      | 输出字符               |
| %s      | 输出字符串              |
| %f与%lf  | 输出具有六位小数部分的小数      |
| %o      | 输出八进制整数(不输出前导符0)   |
| %#o     | 输出八进制整数(输出前导符0)    |
| %x或%X   | 输出十六进制整数(不输出前导符0x) |
| %#x或%#X | 输出十六进制整数(输出前导符0x)  |

指定宽度输出：

| 特殊格式说明符 | 说明                                                                |
| ------- | ----------------------------------------------------------------- |
| %md     | 右对齐，不足前补空格至宽度为m，如果实际位数>m则打印全部                                     |
| %-md    | 左对齐，不足后补空格至宽度为m，如果实际位数>m则打印全部                                     |
| %m.nf   | 右对齐，指定小数部分为n位(不足补0，多出则四舍五入)，<br>不足前补空格至宽度为m(小数点占1位)，如果实际位数>m则打印全部 |
| %-m.nf  | 左对齐，指定小数部分为n位(不足补0，多出则四舍五入)，<br>不足后补空格至宽度为m(小数点占1位)，如果实际位数>m则打印全部 |

* 注意：可以通过省略m只指定小数的小数部分。例：`.6f`表示只输出六位小数的单精度数

### scanf格式输入函数

使用前提：除头文件外，还需要`# define _CRT_SECURE_NO_WARNINGS`

基本语法：`scanf("格式化字符串", 输入表列)`

* 格式说明符：与printf中的一致，但double类型需用`%lf`
* 输入表列：是所要赋值的变量等的地址，可以用`&变量`或`指针`，之间用逗号隔开
* 键盘输入：
	* 多类型录入时，如果影响录入需要使用空格、Tab、回车隔开，不影响时可以不隔开，但是%c之前一定不能隔开。最后回车结束输入
	* 当格式化字符串中有特殊字符时，对应键盘输入内容也得有特殊字符

指定截取位数：

| 特殊格式说明符 | 说明                      |
| ------- | ----------------------- |
| %md     | 自动识别截取输入的m个字符           |
| %mf     | 自动识别截取输入的m个字符，小数点也算一个字符 |
| %mlf    | 自动识别截取输入的m个字符，小数点也算一个字符 |

* 注意：在输入小数时，不能指定输入的小数位数。例：`scanf("%5.2f",&f);`

## 程序的三种基本结构

### 顺序结构

顺序结构是程序默认的执行流程，从上往下依次运行的

### 选择结构

#### if分支

基本语法：
```C
if (关系表达式A)
	语句A;
else if (关系表达式B)
	语句B;
else
	语句C;
```

* 注意：
	* 语句：可以是`{}`括起的复合语句，也可以是`;`结尾的单语句。一个单语句只对应一个前面的`if`或`else`
	* `else`为与之最近的上一个`if`进行配对
	* 整个if分支之间的判断不能存在其它语句，否则为语法错误
	* 每个 `if`、`else if` 分支中，括号里的“条件表达式”都会被执行一次，直到遇到第一个为真的分支为止。

#### switch分支

格式：
```c
switch(表达式)
{
case 常量1:语句1...;break;
case 常量2:语句2...;break;
...
default:语句组;break;
}
``````

* switch要求：后面表达式可以是整型和字符型，但不能是实型
* case要求：case后面只能是常量
* case执行：直至遇到break，不然执行到整个switch结束才停止，并且执行下一个case时不需要进行判断
* break功能：跳出整个switch语句，单独为一个语句
* default功能：如果其他case后找不到对应常量，则执行default后面语句，与该语句与书写顺序无关（通常放最后面从而不加break）。也可以不使用该语句
* switch嵌套：一个break对应跳出一个switch复合语句

### 循环结构

循环三要素：**初值、条件、增量**（使用for循环记忆）

C语言中的三种循环结构（`for`、`while`、`do...while`）是可以互相转换的

#### for循环

基本语法：
```C
for (初始化语句; 条件判断语句; 条件控制语句)
{
	循环体语句;
}
```

* 次数计算：当增量为++且判断不带=时，次数=|结束条件-初值|；带=时多加1

#### while循环和do...while循环

格式1：
```C
while(表达式)
语句;
```

格式2：
```C
do
	语句;
while(表达式);
```

* 主要区别：`do...while`至少无条件执行一次

应用：辗转相除法——找两个数的最大公约数

* 步骤：两数相除取余，如果余数不为0，则再使用除数取余余数，一直到余数为0时，此时除数为所求值
```C
void main()
{
	int a,b,c;
	int t;
	scanf("%d%d",&a,&b);
	if(a<b) //判断除数和被除数大小以作正确取余
	{
		t=a;
		a=b;
		b=t;
	}
	c=a%b;
	while(c)
	{
		a=b;
		b=c;
		c=a%b;
	}
	printf("最大公约数为：%d",b);
}
```

### 无限循环语句和break及continue

基本语法1：`for (;;)`

* 满足中间表达式为一直真即可

基本语法2：`while (1)`

break：只能写在switch、循环中，用于完全结束一个循环

* 注意：break结束的循环，不会再执行for循环中的条件控制语句

continue：只能写在循环中，表示跳过本次循环，继续执行下次循环

### goto语句?

goto：结合标号，可以跳到代码中的任意地方。一般只用于跳出循环嵌套

实例：
```C
int main()
{
	int i = 1;
a:	
	printf("你好你好%d\n”，i);
	i++;
	goto a;
}
```

* 分析：每当执行到goto语句时，又重新跳到标号a：行中，导致无限循环

# 数组

## 语法

==一维数组==

定义：`数据类型 数组名[下标];`

* 定义时必须有下标
* 长度：只能是整型常量或整型常量表达式或符号常量(**常量**)，不能为变量或浮点数
* 数组大小：一个元素所占字节×元素个数(为下标数)

初始化：`数据类型 数组名[下标] = {元素值表列};`

* 初始化时可以省略下标，此时下标值为`{}`中的元素个数
* 自动初始化：初始化时当下标值>元素个数，剩余元素会自动初始化0值，整数-0，浮点数-0.0，字符-'\\0'
* 注意：
	* 初始化不能拆分为定义+整体赋值，因为引用每次只能引用一个元素
	* 赋值元素的数量≤数组长度，不能大于

注意：无论是一维数组或二维数组的初始化，都不能出现`{}`的赋值。例：`int a[4]={}`或`int a[][4]={{1,2},{},{2,3}}

==一维数组引用==

一维数组元素表示：`arr[下标]` 或 `arr` 

* 每次只能引用一个元素，不能引用整个数组
* 下标下限：0；下标上限：最大长度-1
* 注意：数组的引用索引可以是变量

==二维数组==

初始化1：`数据类型 数组名[常量表达式1][常量表达式2] = {{arr1},{arr2},...};` #C 

初始化2：`数据类型 数组名[常量表达式1][常量表达式2] = {值1,值2,值3,值4...};` #C 

* 注意：二维数组的初始化可以省略行下标，但不能省略列下标

==二维数组引用==

二维数组引用：`arr[行下标][列下标]`

## 索引遍历数组

==一维数组遍历==

要点：利用`sizeof(数组名) / sizeof(数组数据类型)`确定数组长度，即数组长度=总数据所占字节/一个类型数据所占字节

```C
int main()
{
	int arr[5] = { 1,2,3,4,5 };
	int len = sizeof(arr) / sizeof(int);
	for (int i = 0; i < len; i++)
	{
		printf("%d\n", arr[i]);
	}
}
```

字符串数组遍历：
```C
char arr[] = "i cash you";

方法一：直接使用字符串名
printf("%s",arr);

方法二：使用结束标记'\0'
int i = 0;
while (arr[i] != '\0')
{
    printf("%c", arr[i]);
    i++;
}
```

==数组作为形成形参时==

注意：数组作为形参时传递的是数组的首地址，故只能将len的计算放到函数外

```C
int main()
{
	int arr[5] = { 1,2,3,4,5 };
	int len = sizeof(arr) / sizeof(int);

	printArr(arr,len);
}

void printArr(int arr[], int len)
{
	for (int i = 0; i < len; i++)
	{
		printf("%d\n", arr[i]);
	}
}
```

==二维数组遍历==

```C
int arr[][3] = { {1,2,3},{11,22,33},{111,222,333} };

for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }
```

## 应用

### 数组型斐波那契数列

含义：前两项都是一，第三项开始每一项都等于前两项之和

```C
#include "stdio.h"

void main()
{
	int a[20]={1,1};
	int i;
	for(i=2;i<=19;i++)
		a[i]=a[i-1]+a[i-2];
	for(i=0;i<20;i++)
	{
		printf("%6d",a[i]);
		if((i+1)%5==0)
			printf("\n");
	}
}
```

* 只有20个数

### 冒泡排序

思想：从数组的首尾轮询，找到该位与后面递减所有位中的的最大数，放最后

升序版：从左往右，大的往后冒泡
```C
void main()
{
	int a[10]={10个数}
	int t,flag; //作为交换结束标记
	for(int i=;i<=9;i++)
	{
		flag=0;
		for(int j=0;j<=9-j;j++)
		{
			if(a[j]>a[j+1])
			{
				t=a[j];
				a[j]=a[j+1];
				a[j+1]=t;
				flag=1;
			}
		}
		if(flag==0)
			break;
	}
}
```

* flag作用：如果某一趟冒泡过程中一次交换都没有发生，就提前结束排序
* 降序版：从左往右，小的往后冒泡。操作：只需将内层循环的if中>改为<

# 函数

在C语言中调用库函数时应包含对应的头文件，自定义函数则不需要

一个函数由**函数首部**和**函数体**组成，函数体又包含语句部分和声明部分

函数分类：有参函数、无参函数、空函数(函数体为空)

使用顺序：定义-调用 或 声明-调用-定义

函数的递归调用：直接或间接调用自己称为递归调用。分为直接递归和间接递归

* 注意：main函数不能调用自己

函数递归的解题思路：

* 如果该函数递归次数较少，则从最内层开始推
* 如果该函数递归次数很多，则采用值表找规律

函数的实参传递分为**值传递**和**地址传递**：

* 值传递：实参单元仍保留并维持原值，没有改变。实参向形参的数据传递是“值传递”，**单项传递**，只能由实参传给形参，而不能由形参传给实参。**实参和形参在内存中占有不同的存储单元**，实参无法得到形参的值
* 地址传递：函数的参数是数组名或者指针。传递的是数组的首地址或指针的值，而形参接收到的是地址，即指向实参的存储单元，**双向传递**，**形参和实参占用相同的存储单元**，即形参和实参是相同的
* 另说法：形参与实参占用不同存储单元，只是在地址传递中，它们指向了同一存储单元

函数的结束：调用函数时为其分配存储单元，函数调用结束后释放其存储单元

## 语法

定义语法：
```C
返回值类型 函数名(形参列表)
{
	函数体;
	return 返回值;
}
```

* 定义位置：自定义函数要写在main函数上面，或写main函数下面，使用时先声明函数。声明格式：`返回值类型 函数名(形参列表);`，可以只保留数据类型不写参数名，且参数名可以与原来不一样
* 形参列表：定义的一维数组可以没有长度，二维可以没有列下标但要行下标
* `return`：
	* 当为void类型函数时，可以写或不写；但其它类型函数不写时会返回一个不确定的值
	* return后面有`变量++`时还是会自增
* 注意：函数之间是同级的，不能嵌套定义，但可以嵌套调用

其它概念：

* 实参与形参：实参负责传递，形参负责接收。当实参与形参类型不同时，以形参为准
* 主调函数与被调用函数：带形参为被调用函数，实参为主调函数

调用语法：`[接收变量 =] 函数名(实参列表);` #C 

* 函数的递归调用：在调用一个函数的过程中又出现直接或间接地调用该函数本身，称为函数的递归调用
	* 理解：函数的递归就是反复在做一件事
* void类型函数调用时不能作为计算表达式

## 常用函数

### stdio.h

全称：Standard Input Output

| 函数                | 功能        | 说明                           |
| ----------------- | --------- | ---------------------------- |
| printf("占位符",内容)  | 打印语句      |                              |
| scanf(‘格式符“,变量地址) | 键盘录入并赋值变量 |                              |
| getchar()         | 输入单个字符    | 返回值为输入内容                     |
| putchar(c)        | 打印单个字符    | 不带换行                         |
| gets(str)         | 赋值字符串     | 相比scanf能够接收带空格的字符串，多次使用会覆盖内容 |
| puts(str)         | 打印字符串     | 结尾自带换行                       |

### math.h

| 函数                     | 功能     | 说明            |
| ---------------------- | ------ | ------------- |
| double pow(num1, num2) | 幂      | 计算num1的num2次幂 |
| double sqrt(num)       | 算术平方根  | 计算num的算术平方根   |
| double ceil(num)       | 上取整    | 对num向上取整      |
| double floor(num)      | 下取整    | 对num向下取整      |
| int abs(num)           | 整型绝对值  | 计算整型num的绝对值   |
| double fabs(num)       | 浮点型绝对值 | 计算浮点型num的绝对值  |

* 特殊：abs函数使用的标头为<stdio.h>

### stdlib.h

| 函数     | 功能    | 说明           |
| ------ | ----- | ------------ |
| rand() | 生成随机数 | 数的范围为0~32767 |

rand()实际应用：生成三位数的随机数
```C
rand()&900+100  //(100.999)
```

### string.h

| 函数                 | 功能      | 说明                                                                          |
| ------------------ | ------- | --------------------------------------------------------------------------- |
| strlen(str)        | 获取字符串长度 | 会统计转义字符，不会统计结束标记符'\0'，**统计到'\0'前结束，并且八进制数的'\0??'比结束标记符优先级高**                |
| strcpy(str1,str2)  | 复制字符串   | 将str2内容拷贝覆盖到str1，str1的长度必须大于str2内容长度                                        |
| strcat(str1,str2)  | 拼接字符串   | 拼接str2到str1后，str1的长度必须满足总拼接长，str1内容为str1纯内容+str2纯内容+`'\0'`                  |
| strcmp(str1,strt2) | 比较字符串   | 自左向右逐个字符按 ASCII 码值大小进行比较。如果str1=str 2，返回0；如果str1>str2，返回1；如果str1<str2，返回-1。 |

# 指针

## 语法
 
指针：就是地址

* 另理解：指针是变量，是存放地址的变量

指针变量：存储了内存地址(首地址)的变量，指向变量，大小与它指向的变量类型无关，取决于编译环境，32位占用4个字节，64位占用8个字节

* 理解：指针变量存储了谁的地址，就是指向谁

指针变量定义：`数据类型 *指针变量名;`

* 数据类型：定义的指针类型应该与指向的变量的类型一样
* 注意：只定义时指向了一个随机的内存的地址，是野指针，为安全通常要NULL初始化

空指针定义：`int *p=0`或`int *p=NULL;`(其中NULL为宏常量，值为0)

malloc分配指针例子：`int *a; a=(int *)malloc(sizeof(int));`

指针变量赋值：`指针变量名 = &变量;`或`指针变量名 = 指针变量`或`*指针变量名=*指针变量`

* 第一个：表示把变量地址赋给指针变量，指向该变量（地址传递）
* 第二个：表示把另一个指针变量赋给指针变量，变同一指向（地址传递）
* 第三个：表示把指针的指向赋给指针变量的指向，指向不变，但指向变量的值改变（值传递）
* 注意：不同类型的指针变量赋值时需要强制转换

指针的操作：&和\*

* &取地址运算符：用获取某个变量、数组、函数的地址。例：`&变量`表示获取变量的地址
* \*指针运算符：用于获取指针的指向内容。例：`*指针变量`表示获取变量值

注意：区分指针变量存储的内容与指向的内容，指针变量存储的内容是变量的地址，指向的内容是变量值

==指针变量的输入与输出==

输出指针变量值：`printf("格式化字符串",*指针变量名);`

输入赋值指针变量值：`scanf("格式化字符串字符串",指针变量);`

## 函数的地址传递

作用：当函数的形参为指针时，此时传递方式为**地址传递**，实参可以被改变

例：定义只交换变量值，不交换指针变量的地址的函数
```C
void fun(int *p, int *q)
{
	int t;
	t = *q; *q = *p; *p = t;
}

void main()
{
	int a = 3, b = 5;
	fun(&a, &b);
	printf("%d,%d", a, b);
}
```

其它作用：返回多个函数值

## 其它指针类型？

==void* 指针==

void\*为空类型或无类型指针，指向空类型或不确定类型的数据

特性：void* 类型指针可以与任意类型指针相互转换(隐式转换即可)，但不能通过该指针获取内存地址中的数据和指针运算

注意：定义时指向的是不确定类型数据，赋值后指向了确定类型数据，但自身并没有类型信息(数据有类型指针没类型)

 应用：作为函数形参接收任意类型指针
```C
# 函数功能：交换指定长度的两个变量值
void swap(void *p1, void *p2, int len)
{
	// 把void类型的指针，转成char类型指针
	char *pc1 = p1;
	char *pc2 = p2;

	char tmp = 0;

	// 以字节为单位，一个字节一个字节进行交换
	for (int i = 0; i < len; i++)
	{
		tmp = *pc1;
		*pc1 = *pc2;
		*pc2 = tmp;

		pc1++;
		pc2++;
	}
}
```

* 通过void* 类型指针获取数据方法：将void类型指针转换为其它类型指针利用即可

NULL空指针：不指向任何有效内存地址，用于指针变量初始化，指针变量值为NULL(整数形式为0)，用于判断(与"NULL"和0)不用于打印

## 数组与指针

数组名退化：数组名直接使用是会退化为**指向该数组中首元素的指针**，即数组的首地址。例：一维数组名退化的首地址表示数组中的**首元素的地址**；二维数组名退化的首地址表示第一个行元素的**整行地址**或**第一个元素的地址值**，需要看赋值的对象。例如：定义为`char str[10][20]`，赋值给`char *p`为第一个元素的地址值，赋值给`char (*p)[20]`为整行地址

字符串的退化：直接的字符串名会是第一个字符的地址

没有退化：如果没有退化则会表示**整个数组**，使用`sizeof` 和 `&`时不会退化。例：`&一维数组`和`&二维数组`都表示整个数组

==指针运算(步长)==

步长：用于地址的偏移，一个步长相当于指针移动一次，至于走了多少字节，与所指向的数据类型有关(变量、数组、地址)

一维数组中的步长：在一维数组中，指针存储的是列元素的地址，p+1表示走向下一个元素的地址，p-1表示走向上一个元素的地址，每次走一个列元素字节数

二维数组中的步长：在二维数组中，指针存储的是行元素的地址，p+1表示走向下一行的地址，p-1表示走向上一个行的地址，每次走一个行元素字节数

总结：在步长的字节计算中，**走一步是相对于指针当前指向谁而言的**。指针指向变量则走一个数据类型变量字节数；指针指向数组则走数组个数据类型变量字节数；指针指向地址(无论变量还是数组)则走一个操作系统位数字节数（指向指针的指针）

指针的运算：指针可以单个进行增减，但两个指针之间只能进行互减，此时结果表示该两指针的间隔步长，此外还能比较大小

==地址变量和地址常量==

数组名是固定不变的地址常量，不能进行赋值运算，不能在定义后再赋值，故应当初始化时就赋值，但将地址名赋值给指针变量后，指针变量的指向是可变的。函数名同理

例子：
```C
int a[10] = {0,1,2,3,4,5,6,7,8,9};

a++; //×

int *p = a;
p++; //√
```

==数组的引用==

一维数组引用形式：

* 下标法：`a[i]`
* 指针法：`*(a+i)`

二维数组的引用形式：

* `a[i][j]`
* `*(*(a+i)+j)
* `*(a[i]+j)`
* `(*(a+i))[j]
* 解引用：`数组名`表示行元素地址，`*数组名`表示列元素地址，`**数组名`表示列元素内容
	* 行元素地址应该赋值给数组指针，列元素地址应该赋值给指针变量

==函数之间对一维数组的引用==

| 实参     | 形参    | 传递方式    |
| ------ | ----- | ------- |
| 数组元素   | 变量    | 值传递     |
| 数组元素地址 | 指针    | 地址传递    |
| 数组名    | 数组或指针 | (首)地址传递 |

示例：
```C
#include <stdio.h>

// 1. 值传递：传数组元素给变量
void val_func(int x) {
    x = 100; // 只改形参
}

// 2. 地址传递：传数组元素地址给指针
void ptr_func(int *p) {
    *p = 100; // 改实参内容
}

// 3. 地址传递：传数组名给数组形参或指针形参
void arr_func(int arr[], int sz) {
    arr[0] = 200;
}
void arr_ptr_func(int *arr, int sz) {
    arr[1] = 300;
}

int main() {
    int a[3] = {1, 2, 3};

    val_func(a[0]);
    printf("After val_func: a[0] = %d\n", a[0]); // 1

    ptr_func(&a[0]);
    printf("After ptr_func: a[0] = %d\n", a[0]); // 100

    arr_func(a, 3);
    printf("After arr_func: a[0] = %d\n", a[0]); // 200

    arr_ptr_func(a, 3);
    printf("After arr_ptr_func: a[1] = %d\n", a[1]); // 300

    return 0;
}
```

* 注意：函数中的数组实参不需要定义长度

## 指针与变量、数组、函数

==数组元素的指针变量==

含义：存储了数组中元素地址的指针变量，指向变量，本质还是一个存储变量地址的指针变量

实例：
```C
//  一维数组
int arr[] = {1,2,3,4,5,6,7,8};
int *p = arr;
int *p = &arr[0];

//  二维数组
int arr[2][3] = {1,2,3,4,5,6};
int *p = arr[0];
int *p = &arr[0][0];
```

* 步长：指向变量，一步长为一个变量长

==数组指针==

含义：存储了整个数组地址的指针变量，指向整个数组，本质是一个指针变量

初始化：`数据类型 (*数组指针名)[数组长度] = 数组地址;` #C 

* `数据类型`：为指向的数组存储的数据的类型
* `[数组长度]`：为所要指向的数组的数组长度。指向一维数组时为该数组长度，指向整个二维数组时`[行长度][列长度]`表示，指向二维数组的行时`[列长度]`表示
* `数组地址`：根据对应指针定义进行地址赋值即可

```C
int arr[5] = { 1,2,3,4,5 };
int (*p)[5] = &arr;
```

* `p`等同于`&arr`，存储整个数组地址，指向整个数组；`*p`等同于`arr`，存储了`&arr[0]`地址，指向`a[0]`

==指针数组==

含义：存储了地址作为元素的数组，本质是一个数组

初始化：`数据类型 *数组名[长度] = {值1,值2,...};` #C 

* `[长度]`：表示这个数组中能够存储的指针元素个数
* 解引用：与普通数组类似，直接数组名为第一个地址元素的地址，一次解引用为地址元素，两次解引用才为元素内容。例：`int *arr[]={&a,&b,&c};`，`arr`为`&a`的地址，`arr[0]`为`&a`，`*arr[0]`为元素a
* 作用：存储若干个字符串。例：`char *strs[4] = {"abcd","efgh","ijkl",...};`
	* `strs`表示`"abcd"`整个的地址，`strs[0]`表示`"abcd"`（字符a的地址）,                 `*(strs[0]+2)`表示c

区分定义数组指针与指针数组：符号结合优先级：`( ) > [ ] > *`（函数中`()`看做`{}`），哪个先结合本质就是谁，命名时在后面

==函数指针==

含义：存储了一个函数的地址的指针，指向函数，本质是一个指针变量

定义：`数据类型 (*函数指针名)(数据类型列表)`

* `数据类型`：为指向的函数的返回值类型
* `数据类型列表`：为指向的函数的形参列表的数据类型
* 例子：`void (*p)(int *,int *)`

使用：可以`*函数指针(形参)`或`函数指针(形参)`使用，功能一致与普通函数相同

==指针函数==

含义：指的是函数的返回值是一个指针

定义：`数据类型 *指针函数名(形参列表)`

* 数据类型：表示该函数返回值的数据类型

## 指针遍历数组？

##### 一维数组遍历

方法一：指针变量
```C
int arr[] = { 10,20,30,40,50 };
int len = sizeof(arr) / sizeof(int);
int *p = arr;

for (int i = 0; i < len; i++)
{
	printf("%d\n", *p++);
}
```

方法二：数组指针
```C
int arr[] = { 10,20,30,40,50 };
int len = sizeof(arr) / sizeof(int);
int (*p)[len] = &arr;

for (int i = 0; i < len; i++)
{
	printf("%d\n", (*p)[i]);
}
```

注意：\*和++、--符号为同级运算符，但执行顺序是从右向左。例：`*++p`，为先++p后*

##### 二维数组遍历

在二维数组中，不同表达形式的语句具有不同含义，但所指向的地址值可能相同

例：`int a[][4];`，有以下几种不同表达形式（同含义同地址）：

| 表示形式                             | 含义               | 地址   |
| -------------------------------- | ---------------- | ---- |
| a                                | 0行首地址            | 2000 |
| a[0]，\*(a+0)，\*a                 | 0行0列元素地址         | 2000 |
| a+1，&a[1]                        | 1行首地址            | 2016 |
| a[1]，\*(a+1)                     | 1行0列元素a[1][0]的地址 | 2016 |
| a[1]+2，\*(a+1)+2，&a[1][2]        | 1行2列元素a[1][2]的地址 | 2024 |
| \*(a[1]+2)，\*(\*(a+1)+2)，a[1][2] | 1行2列元素a[1][2]的值  | 元素值  |

###### 指针变量

方法：通过取列1元素地址，进行步长遍历
```C
int arr[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };

int *q = &arr[0][0]; //第一种写法
int *q = arr[0]; //第二种写法
for (int i = 0; i < 12; i++)
{
	printf("%d\n", *(q + i));
}
```

* 第二种写法：arr先退化为指向整个一维数组地址，然后0步长获取第一个一维数组地址，最后\*解引用获取一维数组名，再退化为指向0列元素的指针

###### 数组指针

方法：通过一维数组的指针遍历
```C
int arr[3][5] = { {1,2,3,4,5},{11,22,33,44,55},{111,222,333,444,555} };
int (*p)[5] = arr;

for (int i = 0; i < 3; i++)
{
    for (int j = 0; j < 5; j++)
    {
        printf("%d ", *(*p+j));
    }
    printf("\n");
    p++;
}
```

* `*(*p+j)`理解：先`*p`获得一维数组，此时会退化为指向列0元素的指针，然后偏移j步长到新地址，最后\*解引用获得变量值

###### 指针数组

```C
int arr1[] = {1,2,3};
int arr2[] = {1,2,3,4,5};
int arr3[] = {1,2,3,4,5,6,7,8,9};

int len1 = sizeof(arr1) / sizeof(int);
int len2 = sizeof(arr2) / sizeof(int);
int len3 = sizeof(arr3) / sizeof(int);
int lenArr[] = {len1,len2,len3};

int *arr[3] = { arr1,arr2,arr3 };
for (int i = 0; i < 3; i++)
{
    for (int j = 0; j < lenArr[i]; j++)
    {
        printf("%d ", arr[i][j]);
        // printf("%d ", *(arr[i]+j ));
    }
    printf("\n");
}
```

* `arr[i][j]`理解：arr先退化为指向列0元素(新数组)的指针，然后偏移i步长到新地址，之后\*解引用获得新元素(数组)，新数组退化为指向首元素的指针，然后偏移j步长，最后\*解引用获得变量值

# 字符数组与字符串、字符串指针、字符串数组

## 字符串的理解

字符串的理解：字符串是一个(字符)数组，直接使用**字符串名为第一个字符的地址**，**所有对字符串的操作其实都是对字符地址的操作**

==字符串的输入与输出

字符串输入格式：`scanf("%s",字符串);`

* 输入时，其它数据类型需要&取地址，而字符串直接使用就可以

字符串输出格式：`printf("%s",字符串);`

* %s的输出与其它不同，它需要提供的是字符地址而不是变量值，所以不需要解引用
* 注意：%s的输出会识别到第一个`'\0'`前结束。例：`char c[5]={'a','b','\0','c','\0'}; printf("%s",c);`，结果为ab

==字符串的输入和输出函数==

字符串输入函数：`gets(字符串)`

* 与`scanf("%s",字符数组名);`不同，可以接收空格内容
* 注意：多次使用会覆盖全部内容

字符串输出函数：`puts(字符串)`

* 与`printf("%s",字符数组名);`相同

## 字符数组与字符串

==字符数组与字符串==

字符串是字符数组，但字符数组不一定是字符串，只有当字符数组中有`'\0'`结尾才为字符串

字符数组初始化：`char 字符数组名[元素个数] = {'字符1', '字符2', ...};`

字符串初始化一：`char 字符数组名[元素个数] = "字符串";`

字符串初始化二：`char 字符数组名[元素个数] = {"字符串"};`

* 区别：
	* `{'',''}`既可能为字符数组也可能是字符串，`""`或`{""}`必为字符串
	* 字符串的后面必有`'\0'`填补占一个元素长度，当字符数组内容不够时会填补`'\0'`变为字符串
* 注意：不能进行比较(\=\=只比较地址)

字符串长度计算：

* 初始化时有长度，直接=长度
* 英文、符号、数字占用一个字节
* 结束标记`'\0'`占用一个字节，单纯字符数组不计结束标记符
* 中文在vs中占用两个字节
* 多位记为一个转义字符

结尾标识符判断：既可以使用`!=0`也可以用`!='\0'`

## 字符指针或字符串指针

字符指针与字符串指针的定义相同，都是`char *指针名`

初始化：`char *指针名 = 字符地址|"字符串";`

赋值：`指针名 = 字符地址|"字符串";`

解引用：没有解引用时为第一个字符的地址，第一次解引用为第一个字符值

例：
```C
//  字符指针赋值
char ch = 'a';
char *p = &ch;

//  字符串指针赋值
char *p1 = "world";
```

## 字符串数组

初始化：`char 数组名[字符串个数][单个字符串最大长度] = {"字符串1","字符串2",...}`

* 理解：可以理解为字符的二维数组，第一解引用为一维字符数组(字符串)，第二次解引用为单个字符
* 区别指针数组：字符串数组是二维数组，并且存储的是整个字符串

例：
```C
char strs[3][10] = { "apple", "banana", "cherry" };

printf("%s", strs[0]);  //apple
printf("%c", strs[0][3]) //l
```

## 总结定义

| 名词        | 定义              | 本质       |
| --------- | --------------- | -------- |
| 字符        | `char ch`       | 字符型变量    |
| 字符串(字符数组) | `char ch[]`     | 字符类型一维数组 |
| 字符类型的指针数组 | `char *arr[]`   |          |
| 字符(串)指针   | `char *ch`      | 字符类型指针变量 |
| 字符串数组     | `char arrs[][]` | 字符类型二维数组 |

* 记忆：记字符和字符串的定义，名称有指针加`*`，有数组加`[]`

# 编译预处理

C语言提供的预处理功能主要有三种：宏定义，文件包含和条件编译

注意：编译预处理语句都不是C语句，结尾都不需要`;`

## 宏定义

在C语言程序中，符号常量的定义要使用宏定义预处理命令

定义形式一：`#define 宏名 替换文本`

定义形式二：`#define 宏名(参数) 替换文本`

* 说明：宏名习惯用大写字母，但是也可以用小写

注意：使用宏定义时，先进行替换再做计算

* 例子1：`#define k 2+3`，则`k/k`结果为2+3/2+3=6
* 例子2：`#define f(x) x*x int a=6,b=2;`，则`f(a)+f(b)`结果为6\*6+2\*2=40，`f(a+b)`结果为6+2\*6+2=20

## 文件包含

所谓“文件包含”就是指一个源文件可以将另一个源文件的全部内容包含进来，即将另外的文件包含到本文件中。C语言提供了`#include` 命令用来实现“文件包含”

过程：预处理程序查找被包含文件，将其复制到`#include`处，从而使引用函数找到函数的名称、参数个数与类型、返回值类型与具体的函数体

形式一：`#include <文件名>`

形式二：`#include "文件名"`

* 区别：`<文件名>`范围为系统目录；`"文件名"`范围为用户目录+系统目录

## 条件编译

书写在程序任意位置都可

形式一：**#ifdef**判断宏是否已经定义
```C
#ifdef 宏名
程序段1
#else
程序段2
#endif
```

* 说明：如果宏已定义则执行程序段1，否则执行程序段2

形式二：**#ifndef**判断宏是否没有定义
```C
#ifndef 宏名
程序段1
#else
程序段2
#endif
```

* 说明：如果宏没有定义则执行程序段1，否则执行程序段2

形式三：**#if**与普通if功能类似，但只能判断常量表达式或宏值，不能判断变量值
```C
#if 常量表达式/宏值判断
程序段1
#else
程序段2
#endif
```

* 说明：如果判断为真则执行程序段1，否则执行程序段2

# 自定义数据类型

## typedef自定义类型

`typedef` 是给已有类型取一个别名 的关键字，它不会创建新类型

定义格式理解：由原来定义变量时的格式前加typedef，然后定义的变量名就为新类型名

* 例子：
	* 无符号int：`typedef unsigned int newname;`
	* 数组：`typedef int newname[10];`
	* 指针：`typedef int* p;`
	* 函数指针：`typedef (*newname)(int,int);`

## struct结构体类型

在C语言中，数组是表示类型相同的数据，结构体则是若干类型不同数据项的集合

结构体成员：每一个结构体中定义的变量都是结构体的一个成员

结构体变量：采用结构体类型创建的变量

==说明和定义==

可以先说明结构体类型，再定义结构体变量，这两步可以一起写

说明结构体类型：
```C
struct [结构体名]
{
	成员表列;
};
```

* 成员表列：成员声明格式：`类型名 成员名`（与变量定义相同），不需要赋值；同类型成员可以直接连续声明，不用换行；可以嵌套定义，将结构体类型的成员类型可以是结构体类型；结构体成员名可以与结构体变量名相同
* 概念：struct为结构体类型，结构体名又称类型名，与struct一起共称为结构体类型名，后面定义的变量为结构体变量名
* `[结构体名]`：如果没有该部分，则只能在说明时直接定义结构体变量，后面不能再定义
* 结构体变量所占空间字节数=所有成员所占字节数之和，结构体指针变量为4字节

定义结构体变量：`struct 结构体名 结构体变量名;`

* 将`struct 结构体名`作为类型整体使用
* 相同的结构体类型的变量之间可以赋值，但是不能相加减和比较大小

说明结构体类型并定义结构体变量：
```C
struct 结构体名
{
	成员表列;
} 结构体变量1, ...;
```

配合typedef：
```C
typedef struct [结构体名]
{
	成员表列;
} 别名;
```

* 别名：是`struct 结构体名`的别名，也叫结构体类型名

==初始化==

结构体变量初始化：
```C
struct data
{
	int a;
	float b;
} s = {1,1.22};
```

结构体数组初始化1：
```C
struct data
{
	int a;
	float b;
} C[3] = {1,2,3,4,5,6};
```

* 说明：`C[3]`看做是三个结构体变量构成的结构体数组，分别有`C[0]`、`C[1]`、`C[2]`三个结构体变量，`C[0]`为1和2的结构体、`C[1]`为3和4的结构体、`C[2]`为5和6的结构体

结构体数组初始化2：
```C
struct data
{
	int a;
	float b;
} p,C[3] = {p,p,{1,2}};
```

* 说明：同时将结构体变量和具体值赋值给结构体数组
* 结构体数组本身还是数组，比较包含为相同结构类型的结构体变量

结构体指针变量初始化：
```C
struct std
{
	int a[2];
	char ch[10];
	float s;
}std1, *p=&std1;
```

(顺序)初始化：`struct 结构体名 结构体变量名 = {成员值1,成员值2...};`

(自定义顺序)初始化：`struct 结构体名 结构体变量名 = {.成员1 = 成员值1, .成员2 = 成员值2,...}`

* 将(struct 结构体名)当作整体(一种数据类型)使用

==结构体成员引用==

结构体成员的引用，一次只用引用一个，不能一次引用结构体的多个成员

形式一：`结构体变量名.成员名`

形式二：`结构体指针变量名->成员名`

形式三：`(*结构体指针变量名).成员名`

* 符号说明：(.)为成员运算符；(->)为指向运算符
* 符号优先级：`.` > `*`>；`->`>自增自减(++p->x和(++p)->x)

## union共用体/联合体

声明：
```C
union 共用体类型名
{
	成员表列;
}
```

* 成员表列：也可以嵌套结构体
* 成员地址：各个成员共用同一地址

定义和其它操作(引用成员)与结构体相同，将`struct`改成`union`即可

* 存储大小：共用体所占用的存储空间为最大成员所占存储空间

union的内存赋值与读取：

* 赋值：内存大小为最大成员所占字节数，当不指定内存赋值时，默认从最低的字节位开始赋值，如果使用了数组或struct进行索引赋值，则可以从中间字节位进行赋值
* 读取：所有成员默认从最低字节位开始读取对应位数数据，除了使用了数组或struct进行索引读取，则可以从中间字节位进行读取数据

# 文件

## 文件介绍

数据可以用**二进制**和**ASCII**两种代码形式存放

根据数据的组织形式，C语言将文件分为 二进制文件和ASCII文件 两种类型

* 二进制文件：如果不加转换地输出到外存，就是二进制文件，可以认为它就是存储在内存的数据的映像，所以也称之为映像文件(image file)
* ASCII文件：在外存中以ASCII码形式存储，需要在存储前进行转换，每一个字节放一个字符的ASCII代码，ASCII文件又称文本文件
* 无论哪种形式，数据在内存中最终是以二进制形式存储的

## 文件指针

==文件指针==

文件指针定义：`FILE *文件指针名;` #C 

## 文件函数

==打开关闭文件函数==

| 返回值   | 函数                   | 功能          | 说明                                               |
| ----- | -------------------- | ----------- | ------------------------------------------------ |
| FILE* | fopen("文件路径","使用方式") | 打开文件并赋予文件权限 | 返回一个该文件的指针，如果r、a模式下文件不存在则报错返回NULL空指针(0)，w下会创建新文件 |
| int   | fclose(FILE*)        | 关闭文件        | 使文件指针不在指向文件；执行成功返回0，失败返回EOF(-1)                  |

* EOF含义是指文件结束标志
* 注意：文件路径在Ｃ中用\\\

fopen函数中文件使用方式的表示：

| 使用文件方式 | 说明            |
| ------ | ------------- |
| "r"    | 只读模式(文本文件)    |
| "w"    | 覆盖写入模式(文本文件)  |
| "a"    | 追加写入模式(文本文件)  |
| "rb"   | 只读模式(二进制文件)   |
| "wb"   | 覆盖写入模式(二进制文件) |
| "ab"   | 追加写入模式(二进制文件) |

* 记忆：r-读、w-写、a-追加、+-读写、b-二进制文件
* 注意：
	* 除了a时文件位置指针指向文件末尾外，r和w都是指向文件开头
	* w的覆盖是针对两个不同类型的指针文件进行操作的，如果对同一文件进行两次w操作，那么第二次操作是追加不是覆盖

==读取和写入文件函数==

读取和写入函数用于文件的顺序读写

| 返回值   | 函数                               | 功能        | 说明                                                                        |
| ----- | -------------------------------- | --------- | ------------------------------------------------------------------------- |
| int   | fgetc(FILE\*)                    | 读取文件中一个字符 | 一次读取一个字符，读取成功返回读取字符，读取失败返回EOF(-1)                                         |
| int   | fputc(写入字符,FILE*)                | 写入文件一个字符  | 一次写入一个字符，输出成功返回输出字符，输出失败返回EOF(-1)                                         |
| char* | fgets(数组指针,字符数,FILE\*)           | 读取文件多个字符  | **一次读取 字符数-1个字符**，如果读取到'\n'则结束读取，读完补充'\0\到数组末尾，读取成功返回该数组的指针，读取失败返回NULL空指针 |
| int   | fputs(字符串指针,FILE*)               | 写入文件一个字符串 | 一次写入一个字符串(不包括末尾'\\0'，不会换行)，成功写入返回0，写入错误则返回非0值                             |
|       | fprintf(FILE*,占位符,变量)            | 格式化写入数据   | 后两个参数同printf参数一样，将原printf打印的内容写入文件，多个变量逗号隔开                               |
|       | fscanf(FILE*,格式符,&变量)            | 格式化读取数据   | 后两个参数同scanf参数一样，将文件数据录入变量中，多个变量时逗号隔开                                      |
| int   | fread(数组指针,每个元素字节大小,元素个数,FILE*)  | 数据块读取字节数组 | 按元素个数进行读取，总读取大小为每个元素字节大小×元素个数，并将读取的内容赋值给数组地址，读取成功返回读取元素个数，失败返回0           |
| int   | fwrite(数组指针,每个元素字节大小,元素个数,FILE*) | 数据块写入多个内容 | 将数组内容写入文件，数组大小为每个元字节大小×元素个数，写入成功返回写入元素个数，失败返回0                            |
 
* 使用区别：`fgetc()`用于字符、`fgets()`用于字符串、`fpritf()`用于格式化数据(int、double等)、`fread()`用于内存块
* 注意：
	* 每次读写操作都会使文件位置指向变化，并且是共用的，使下一次读取不是从头开始，只有重新关闭再打开文件或`rewind()`会刷新到文件首
	* `fgetc()` /  `fgets()` / `fread()`在读取内容时，如果原来字符或数组有内容会进行从头部分覆盖，并且数组从头覆盖时如果后面部分没有被覆盖则会按原来输出而不是为空
	* `fscanf()`读取时，会跳过(空格`' '`、制表符`\t`、换行`\n`)，而读取时会到不同的格式化内容或换行符才结束。例：`fprintf()`三次分别写入7、8、9，而`fscanf(fp,"%d",&n)`会直接读取三次使n=789。所以配合`fprintf()`多次写入相同类型数据时，要用空格或其他符号将每次的数据隔开

==文件定位函数==

文件定位函数用于文件的顺序读写，也可以用于顺序读写

文件位置标记：读写时会指向下一个字符位置

| 函数                      | 功能       | 说明                                                                     |
| ----------------------- | -------- | ---------------------------------------------------------------------- |
| rewind(FILE* )          | 标记指向移至开头 | 将所指文件的位置指针(插入点)移动到文件首部                                                 |
| fseek(FILE*,位移量(L),起始点) | 改变标记位置   | 移动至文件的起始点+偏移量位置，位移量是相对于起始点而言的，正数值先后跳，负数值向前跳，起始点0表示文件开头，1表示当前位置，2表示文件末尾 |
| long ftell(FILE*)       | 测定标记位置   | 成功指向返回相当于文件开头位移量的值，失败返回-1L                                             |

* `fseek()`说明：如果使用该函数后退然后写入时原来位置有内容，则会进行从此处开始的覆盖

fseek函数中起始点的表示：

| 起始点  | 字符表示     | 数字表示 |
| ---- | -------- | ---- |
| 文件首  | SEEK_SET | 0    |
| 当前位置 | SEEK_CUR | 1    |
| 文件末尾 | SEEK_END | 2    |

==文件出错检测结束==

| 函数            | 功能                      | 说明             |
| ------------- | ----------------------- | -------------- |
| feof(FILE*)   | 检测当前标记位置是否为文件结尾，需要先读取一下 | 是则返回1，不是返回0    |
| ferror(FILE*) | 检测fopen返回的指针是否发生错误标志    | 没有错误返回0，错误返回非0 |

==程序例子==

判断打开的文件是否异常：
```C
fp=fopen("a.txt","r")==NULL
```

判断当前读取位置是否为结尾：
```C
// 一、使用fgetc()对内容进行判断
while(fgetc(fp)!=EOF)

// 二、使用feof()对当文件位置标识判断
ch=fgets(arr,100,fp);  //先读取第一个字符再进行判断
while(!feof(fp))
{
	ch=fgets(arr,100,fp);
}
```

* 第一种用于判断对字符的操作的结束；第二种用于判断其它类型数据操作的结束

功能：读取文件a.txt中的字符逐个输出到屏幕
```C
void main()
{
	FILE *fp;
	if((fp=fopen("a.txt","r"))==NULL)
	{
		printf("Can't open the file!");
		exit(0);
	}
	ch=fgetc(fp);
	while(!feof(fp))
	{
		putchar(ch);
		ch=fgetc(fp);
	}
	fclose(fp);
}
```

# 应用题

## 斐波那契

函数功能：通过递归输出n项斐波那契

```C
int f(int i)
{
	if(i==0)
		return 0;
	else if(i==1)
		return 1;
	else
		return f(i-1)+f(i-2);
}

void main()
{
	int i,n;
	scanf("%d",&n);
	for(i=0;i<n;i++)
		printf("%d,,",f(i));
}
```

* 递归理解：反复找前一个和前第二个数

## 找最小公倍数

思路：找到最大数，然后依次使用 最大数×i去除以这两个数为0即找到(i=1、2、3、...)

```C
void main()
{
	int x1,x2,max,j,i=1;
	scanf("%d,%d",&x1,&x2);
	max=max(x1,x2);
	
	while(1)
	{
		j=max*i;
		if(j%x1==0 && j%x2==0) break;
		i++;
	}
}
```

## 判断质数/素数

思路：假设该数为(int)num，则循环执行判断num%(2~num/2)或num%(2~sqrt(num))是否为0

```C
prime(int num)
{
	for (i=2;i<=num/2;i++)
		if(num%i==0) return(0);
	return (1);
}
```

## 指针选择排序

要求：对数组中的字符进行从小到大排序，然后删除连续重复部分

排序思路：从第一位开始循环，另一个指针向后走，内循环找到最小字符用另一个指针记录地址，判断该地址是否为外循环当位，如果是则不需要交换，不是则进行交换

删重思路：从第一位开始，另一个指针向后走，内循环判断另一个指针内容是否与当前内容相同，如果不同则拷贝到当前指针的后一位

```C
void main()
{
	char str[100],*p,*q,*r,c;
	printf("please input");
	gets(str);
	// 选择排序
	for(p=str;*p!='\0';p++)
	{
		for(q=p,r=p;*q!='\0';q++)
		if(*r>*p)r=q;
		if(r!=p){c=*r;*r=p;*p=c;}
	}
	// 删出连续重复
	for(p=str;*p!='\0';p++)
	{
		for(q=p;*p==*q;q++);
		strcpy(p+1,q);
	}
}
```

## 利用传入标志区分找最大值或最小值

思路：当flag=1时，此时直接判断两数大小；当flag=-1时，对两个数乘以flag变负进行大小比较，变负后的最大值也就变成了最小值

```C
float fun(float *d,int n;int flag)
{
	float y;int i;
	y=*d;
	for(i=1;i<n;i++)
		if(flag*d[i]>flag*y) y=d[i];
	return y;
}
void mian()
{
	float a[6]={3,-2,6,9,1};
	fun(a,5,-1); //找最小值
}
```

## 计算阶乘

思路：使用函数递归

注意：0的阶乘也要考虑

```C
int fun(int n)
{
	if (n==1 || n==0) return 1;
	return n*fun(n-1);
}
```

## 计算某个数的整数位个数

思路：先将该数转换为整型，然后不断把整数除以 10，直到变成 0，统计次数

注意：该整数可能为负数，需要先转换为正数

```C
int fun(int n)
{
	int i=0;
	if(n<0) n=-n;
	while(n>0)
	{
		n/=10;
		i++;
	}
	return i;
}
```

## 计算当天为今天第几天

题目要求：考虑闰年

* 闰年：2月为29天而不是28天
* 闰年判断：能被4整除而不能被100整除，或能被400整除

代码：
```C
int year=, day=, month=;
int Month[12]={31,28,31,30,31,30,31,31,30,31,30,31};

int Day=0;
for(i=1;i<month;i++)
{
	Day+=Month[i-1];
}

Day+=day;

if(month>2)
	if(year%4==0&&year%100==0||year%400==0)
	Day+=1;
```

## 其它思路

按列输出二维数组时，只要将遍历时的内外层for变量交换即可

n×n二维数组的左下半角输出条件 i<=j