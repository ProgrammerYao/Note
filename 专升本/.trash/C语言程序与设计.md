# 核心语法

## 注释

单行注释：//内容

多行注释：/\*内容\*/

快捷键：Ctrl+k再Ctrl+c   或   Ctrl+k再Ctrl+u 

## 常量与变量

### 常量

含义：在运行程序过程中，其值不能被改变的量称为常量

总有有以下几类：

| 常量类型  | 说明                                           | 举例             |
| ----- | -------------------------------------------- | -------------- |
| 整型常量  | 正数、负数、0                                      | 53             |
| 实型常量  | 所有带小数点的数字                                    | 1.23           |
| 普通字符  | 单引号引起来的字母、数字、英文符号                            | 'A'            |
| 转义字符  |                                              | \\\\           |
| 字符串常量 | 双引号引起来                                       | "中文"           |
| 符号常量  | 由#define定义的变量；格式：`# define 变量 值；`会固定整个文件该变量值 | \# define a 20 |

* 语法规范：
	* 字符常量：必须有单引号+一个字符，允许字符为空格等，但空内容则语法错误
	* 字符串常量：允许双引号内容为空
* 符号常量：在预编译时处理，作简单的字符串替换

### 变量

含义：可以存储数据，其值可以在程序运行期间改变，分为局部变量和全局变量，并且有不同的数据类型和存储类别

#### 语法

定义格式：`[存储类别] 数据类型 变量名;` #C 

使用(赋值/修改值)：`变量名 = 数据值;` #C 

一步到位：`[存储类别] 数据类型 变量名1 = 数据值1[, 变量名2 = 值2];` #C 

* 可以一次定义多个变量，但不推荐

#### 数据类型

数据类型分为三种：整型、浮点型、字符型

规定字节大小：double≥float≥long long≥long≥int≥short≥char（小数永远大于整数）

不同系统、编译器中数据类型占用字节数都不一样，可以用sizeof来确定：

* sizeof操作符使用：`pirntf("%zu",sizeof(数据类型/变量));` #C 

##### 整型

| 数据类型                          | 格式符  | 字节数 | 常量后缀      | unsigned中格式符 |
| ----------------------------- | ---- | --- | --------- | ------------ |
| short/shot int(短整型)           | %hd  | 2   | 10        | %hu          |
| int(整型)                       | %d   | 4   | 10        | %u           |
| long/long int (长整型)           | %ld  | 4   | 10L/10l   | %lu          |
| long long/long long int(长长整型) | %lld | 8   | 10LL/10ll | %llu         |

* signed(默认)/unsigned用于整型指定取值范围是否包含负数(范围大小不变)
	* 定义：`signed/unsignde 数据类型 变量名；`
	* 无符号打印例子：`unsigned int a = 10; printf("%u",a);`（格式符中的d改为u）

##### 浮点数类型

| 数据类型             | 格式符 | 字节数 | 常量后缀    |
| ---------------- | --- | --- | ------- |
| float(单精度)       | %f  | 4   | 20F/20f |
| double(双精度)      | %lf | 8   | 20      |
| long double(高精度) | %lf | 8   | 20L/20l |

* 所有浮点数类型的取值范围都大于整型类型

##### 字符类型

| 数据类型   | 字节数 |
| ------ | --- |
| char() | 1   |

* 数据格式：'值'，ASCII值 或 用 '转义字符'
* 用%d占位符时则显示对应字符的ASCII值

##### 数据类型转换

###### 隐式转换

情景：不同的数据类型进行计算、赋值等操作，会触发隐式转换

转换规则：

* 取值范围小的，和取值范围大的进行运算，小的会先提升为大的，再进行运算
* char short 类型的数据在运算的时候，都会直接先提升为int，然后再进行运算

注意：当char类型转换为int类型时，则会根据ASCLL表进行转换。如：A→97、a→85

###### 强制转换

如果把取值范围大的，赋值给取值范围小的，就需要进行强制转换

* 例：short s1= 10; short s2 = 20; short result=(short)(s1 + s2);
	* 不用(short)时将会隐式转换，result仍是short，建议转换时加上

注意：将小的转换为大的数据不会变化，但将大的转换为小的数据可能出问题。原因：大字节数据会丢掉前面部分字节使其变为小字节数据

#### 变量属性(作用域、生存期、存储类)

##### 作用域

局部变量：在函数内部定义的变量，包括形参

作用域：从定义的位置到函数的'}'处

全局变量：在函数的外部定义的变量

作用域：从定义的位置到整个程序结束

注意：在同一作用域的两个同名的局部变量和全局变量，使用时为局部变量

##### 生存期和存储类

==生存期(生命周期)==

根据变量的生存期来辨别存储方式分为两种：静态存储方式和动态存储方式(寄存器另计)

静态存储方式：指在程序运行期间由系统分配固定的存储空间的方式，直到整个程序结束。例如：静态存储区(包括堆)

动态存储方式：指在程序运行期间根据需要进行动态的分配存储空间的方式，函数调用时临时分配内存，函数结束时释放。例如：动态存储区(包括栈)

* 注意：由于是动态存储，所以每次调用函数时重新定义该变量，所以每一次变量的地址不相同

==存储类别==

基本语法：`存储类别 数据类型 变量名;`

`auto`自动变量：采用动态存储方式。局部变量默认使用了该存储类别

* 不能用于全局变量

`static`静态变量：分为静态局部变量和静态全局变量。静态局部变量：改用静态存储方式存储该变量；静态全局变量：全作用域只是在其定义的源文件中有效，不能被外文件extern

* 只定义时会有默认初始值
* 全局变量不带存储类别时，默认使用了static，然而是隐式地使用，只改变了生存期
* 当调用函数时定义了静态局部变量后，第二次调用的定义语句无效

`register`寄存器变量(了解)：建议将定义的变量放在CPU的寄存器中；寄存器的存取速度远高于内存，从而提供执行效率

* 作用对象：局部变量

`extern`外部变量：将全局变量的定义声明到该extern处，包括从其他文件的全局变量，从而扩大全局变量的作用域

* 作用对象：所有源文件的全局变量
* 使用：声明时不能使用，声明后才可以正常使用

### 常变量

常变量：具有数据类型和名字的常量

定义：`const 数据类型 常变量名;` #C

定义并赋值：`const 数据类型 常变量名 = 值;` #C

特点：不能更改其值和数据类型

## 标识符

含义：代码中所有我们自己起的名字。比如变量名、函数名等

标识符命名规则：

1. 只能由数字、字母、下划线(\_)组成
2. 不能以数字开头
3. 不能是关键字(高亮蓝色字)

注意：标识符区分大小写。如if是关键字，但If不是

文件命名规则建议：全部小写，单词之间用下划线隔开，开头可以用数字

## printf输出语句

### 语法

基本语法：`printf("格式化字符串"，输出表列)` #C

* 使用：占位符应使用对应变量名的数据类型
* 特殊：纯用字符串可以直接 "内容" 表示
* 变量类型对应格式说明符：char-%c，char[]-%s，int-%d，double-%f或%lf
* 可以使用”%.数字f“指定小数部分的位数(默认六位)

### 输出换行

| 操作系统    | 换行符    |
| ------- | ------ |
| windows | \\r\\n |
| mac     | \\r    |
| linux   | \\n    |

* 但是c语言中会自动将\\n转换为\\r\\n，所以直接写\\n即可

## scanf输入语句

基本语法：`scanf("格式化字符串", 输入表列)` #C 

* 格式说明符：指定录入数据的数据类型，可以使用多个，建议空格隔开。与printf中的格式符一致，但double只能使用%lf表示
* 输入表列：是所要赋值的变量等的地址
* 注意：
	* 调用该函数前需要预处理：`# define _CRT_SECURE_NO_WARNINGS`（位于include前）
	* 在scanf()中占位符不要有其它内容，不然输入时对应位置需要有对应内容才能执行。例：scanf("%d\\n", a); 需要输入：10\\n

## 运算符

运算符分为算术运算符、自增自减运算符、赋值运算符、关系运算符、逻辑运算符、三元运算符

### 算术运算符

| 符号  | 说明  |
| --- | --- |
| +   | 加法  |
| -   | 减法  |
| *   | 乘法  |
| /   | 除法  |
| %   | 取余  |

注意：

* %：取余运算中两个数必须为整数
* 两个整数相除时结果会舍弃小数部分
* 整数与小数混合运算时结果为小数

### 自增自减运算符

| 符号  | 说明    |
| --- | ----- |
| ++  | 变量值+1 |
| --  | 变量值-1 |

书写：`++变量`或`变量++`

使用区别：

* 单独使用：单独写一行结果是一样的
* 参与运算：++a表示先加后用，a++表示先用后加

### 赋值运算符

| 符号  | 说明    |
| --- | ----- |
| =   | 直接赋值  |
| +=  | 加后赋值  |
| -=  | 减后赋值  |
| *=  | 乘后赋值  |
| /=  | 除后赋值  |
| %=  | 取余后赋值 |

### 关系运算符

| 符号  | 说明    |
| --- | ----- |
| ==  | 等于号   |
| !=  | 不等于号  |
| >   | 大于号   |
| >=  | 大于等于号 |
| <   | 小于号   |
| <=  | 小于等于号 |

* 返回结果：真为1，假为0

### 逻辑运算符

作用：用于连接两个条件表达式

| 符号   | 说明    | 说明          |
| ---- | ----- | ----------- |
| &&   | 与     | 两边都为真，结果才是真 |
| \|\| | 或     | 两个都为假，结果才是假 |
| !    | 非(取反) | 取反          |

* !数字=0
* 短路效果：符号前一个表达式已经能够得出结果时，第二个表达式不会执行

### 三元运算符

格式：`条件表达式 ？ 值1 ：值2`

* 说明：对条件表达式进行判断，如果true则返回值1，否则放回值2

### 运算符优先级

规律：小括号最高，一元>二元>三元，二元中&&>||>赋值

## 流程控制语句

### 顺序结构

顺序结构是程序默认的执行流程，从上往下依次运行的

### 分支结构

#### if分支

基本语法：
```C
if (关系表达式A)
{
	语句体A;
}
else if (关系表达式B)
{
	语句体B;
}
else
{
	语句体C;
}
```

* 关系表达式：0代表不成立，非0代表成立
* 了解：只有一行语句体时大括号可以省略

#### switch分支

基本语法：
```C
switch (表达式)
{
	case 值1:
		语句体1;
		break;
	case 值2:
		语句体2;
		break;
	...
	default:
		语句体;
		break;
}
```

* 注意：表达式和匹配值不能是实型数据
* case穿透：没有break时，会直接执行下一个条件的case内容

if与switch区别：

* 使用：if用于范围匹配，switch用于值匹配
* 效率：if需要从上往下判断，switch会直接执行符合值的那一行

### 循环结构

#### for循环

基本语法：
```C
for (初始化语句; 条件判断语句; 条件控制语句)
{
	循环体语句;
}
```

* 执行顺序：初始化语句-条件判断语句-循环体语句-条件控制语句——重复

#### while循环

基本语法：
```C
初始化语句;
while (条件判断语句)
{
	循环体语句;
	条件控制语句;
}
```

for与while使用区别：知道循环次数或者循环的范围用for；不知道循环的次数和范围，只知道循环的结束条件用while

#### do while循环

基本语法：
```C
do
{
	循环体语句;
	条件控制语句;
}
while (条件判断句);
```

#### 无限循环语句和break及continue

基本语法：`for (;;)`

基本语法：`while (1)`

break：只能写在switch，循环中，表示结束整个语句

continue：只能写在循环中，表示跳过本次循环，继续执行下次循环

#### goto(了解)

问题：break只能跳出最近的一个循环，不能跳出外循环

goto：结合标号，可以跳到代码中的任意地方。一般只用于跳出循环嵌套

```C
int main()
{
	int i = 1;
a:	
	printf("你好你好%d\n”，i);
	i++;
	goto a;
}
```

* 分析：每当执行到goto语句时，又重新跳到标号a：行中，导致无限循环

# 数组

## 语法

==一维数组==

定义：`数据类型 数组名[长度];` #C 

* 当设定了长度后，长度就固定了；不填写时由赋值决定长度
* 设定的长度必须为确定的值，不然会报错

初始化：`数据类型 数组名[长度] = {值1,值2...};` #C 

* 未赋值位置的默认值：整数-0，小数-0.0，字符-'\\0'

==数组使用==

数组使用：`arr[索引]` 或 `arr` #C 

* 区别：(sizeof中)前者获取特定位置的索引数据，后者获取数组地址或整个数组数据
* 索引范围：0~(最大长度-1)

==二维数组==

初始化1：`数据类型 数组名[一维长度][二维长度] = {{arr1},{arr2},...};` #C 

初始化2：`数据类型 数组名[一维长度][二维长度] = {值1,值2,值3,值4...};` #C 

* 注意：一维数组长度可以灵活填写，但二维数组长度必须有，长度不够时按照存储数据类型对应值进行填补

## 字符数组与字符串与字符串数组

==字符数组与字符串==

知识前提：字符串本质是一个字符数组

字符数组初始化：`char 字符数组名[长度] = {'字符1', '字符2', ...};`

字符串初始化：`char 字符串名[长度] = "内容";` #C 

* 长度(元素个数)区别：
	* 定义的字符串中会隐藏一个结束标记符'\\0'占用一个长度(元素)，所以内容长度=字符数组长度-1，如果长度超出，则会覆盖结束标记符，从而打印错误
	* 定义的字符数组没有'\\0'的结尾标记符，故数组长度等于实际内容长度
* 只定义时需要有长度，初始化时长度可选择不填，内容小于长度时用空字符'\\0'填补位置
* 长度计算：
	* 英文、符号、数字占用一个字节
	* 中文在vs中占用两个字节
	* 结束标记'\\0'：占用一个字节

注意：除定义的"字符"类型的字符串外，其余类型数组没有结束标记符

==字符串数组==

初始化：`char 字符串数组名[一维长度][二维长度] = {"字符串1",  "字符串2", ...};`

==printf打印字符串原理==

原理：printf从指针指向的第一个字符开始，逐个读取字符，直到遇到 `\0` 结束

简易printf函数自定义：
```C
void my_printf(const char *str) {
    while (*str != '\0') {
        putchar(*str); // 打印当前字符
        str++; // 移动到下一个字符
    }
}
```

==字符串输入输出函数==

字符串输入函数使用：`gets(字符串);`

字符串输出函数使用：`puts(字符串);`

作用：主要是gets函数，在`scanf("%s",字符串)`中，不能接收空格数据，而gets函数可以

## 内存和内存地址

内存：软件在运行时，用来临时存储数据的

内存存储方式：内存又划分为一个一个的单元存储数据，一个单元占一个字节

内存地址：内存中存储数据单元的编号，一个地址占一个字节

首地址：数据所占总地址中的第一个地址

举例：int类型数据占4个字节，即占了四个内存单元，四个内存地址
![[Pasted image 20240725005651.png|216]]

&符号获取首地址：&变量 或 &数组  或 指针 或 &指针

* 打印地址语句：`printf("%p", &变量);` #C
	* 十六进制显示结果
* 对于指针：printf("%p", p);和printf("%p", &p);
	* 前者：获取p指针记录的变量的内存地址
	* 后者：获取p指针的内存地址

辨析sizeof：int arr[5]中的sizeof(&arr)、sizeof(arr)、sizeof(arr(0))

* sizeof(&arr)：对arr首地址进行字节统计，64位操作系统中首地址占64位，故占(64/8)8字节
* sizeof(arr)：对arr数组中所有数据进行字节统计，故有(4×5)20字节
* sizeof(arr(0))：对数据中索引为0的一个int数据进行字节统计，故有4个字节

变量到内存获取数据过程：拿到首地址和变量类型对应字节数确定了对应所有字节

数组索引到内存获取过程：![[Pasted image 20240725013152.png|604]]

* 举例int arr[2]
1. 拿到数组中的首地址
2. 通过int类型确定一个索引为四个字节
3. 通过索引(内存中的偏移量)，将取的四个字节偏向第三块，从而获取

内存地址与内存大小关系：

* 32位的操作系统，内存地址以32位的二进制表示
	* 其中内存地址范围：32个0 ~ 32个1(即共有2^32个地址)，一个地址对应一个字节，则对应的内存总共有4GB
* 64位的操作系统，内存地址以64位的二进制表示
	* 其中内存地址范围：64个0 ~ 64个1(即2^64个地址)，一个地址对应一个字节，故64位操作系统最多约有17T内存

## 索引遍历数组

==一维数组遍历==

问题：利用循环遍历数组时需要确定数组长度，而过长的数组又不能一一数出

要点：利用sizeof(数组名) / sizeof(数组数据类型)确定数组长度，即数组长度=总数据所占字节/一个类型数据所占字节

```C
int main()
{
	int arr[5] = { 1,2,3,4,5 };
	int len = sizeof(arr) / sizeof(int);
	for (int i = 0; i < len; i++)
	{
		printf("%d\n", arr[i]);
	}
}
```

字符串数组遍历：
```C
char arr[] = "i cash you";

方法一：直接使用字符串名
printf("%s",arr);

方法二：使用结束标记'\0'
int i = 0;
while (arr[i] != '\0')
{
    printf("%c", arr[i]);
    i++;
}
```

==数组作为形成形参时==

注意：数组作为形参时传递的是数组的首地址，故只能将len的计算放到函数外

```C
int main()
{
	int arr[5] = { 1,2,3,4,5 };
	int len = sizeof(arr) / sizeof(int);

	printArr(arr,len);
}

void printArr(int arr[], int len)
{
	for (int i = 0; i < len; i++)
	{
		printf("%d\n", arr[i]);
	}
}
```

* 写法记忆：将数组和len共作为形参从而调用

==二维数组遍历==

```C
int arr[][3] = { {1,2,3},{11,22,33},{111,222,333} };

for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            printf("%d ", arr[i][j]);
        }
        printf("\n");
    }
```

* 缺点：需要确定数组中的两个长度，且一维数组中每个数组长度必须相同

## 数组常见算法

### 基本查找/顺序查找

从数组的第一个依次往后查找

### 二分查找/折半查找

前提条件：数据中的数据必须是有序的

```C
int binarySearch(int arr[], int len, int num)
{
	int min = 0;
	int max = len - 1;
	while (min <= max)
	{
		int mid = (min + max) / 2;
		if (num > arr[mid])
		{
			min = mid + 1;
		}
		else if (num < arr[max])
		{
			max = mid - 1;
		}
		else
		{
			return mid;
		}
	}
}
```

* 要点：更新查找位置时需要将mid+(-)1

>插值查找
>分块查找

## 冒泡排序

思路：相邻元素两两比较，大的往后放，依次从后往前确定最大值

```C
int arr[] = { 3,5,2,1,4 };
int len = sizeof(arr) / sizeof(int);

for (int i = 0; i < len - 1; i++)
{
	for (int j = 0; j < len - 1 - i; j++)
	{
		if (arr[j] > arr[j + 1])
		{
			int tmp = arr[j];
			arr[j] = arr[j + 1];
			arr[j + 1] = tmp;
		}
	}
}
```

## 选择排序

思路：从0索引开始，跟后面的元素一一比较，小的替换前放，依次确定索引上大的最小值

```C
int arr[] = { 3,5,2,1,4 };
int len = sizeof(arr) / sizeof(int);

for (int i = 0; i < len - 1; i++)
{
	for (int j = i + 1; j < len; j++)
	{
		if (arr[i] > arr[j])
		{
			int tmp = arr[i];
			arr[i] = arr[j];
			arr[j] = tmp;
		}
	}
}
```

# 函数

## 语法

定义语法：
```C
返回值类型 函数名(形参列表)
{
	函数体;
	return 返回值;
}
```

* 返回值类型：没有写默认是int
* 定义位置：自定义函数要写在main函数上面，或写main函数下面时先在main函数上面声明定义的函数。声明格式：`返回值类型 函数名(形参列表);`（不写形参列表也可以）
* 在函数的形参中定义的数组可以没有长度
* 注意：函数之间是同级的，不能互相嵌套定义，但可以互相调用

调用语法：`[接收变量 =] 函数名(实参列表);` #C 

* 函数的递归调用：在调用一个函数的过程中又出现直接或间接地调用该函数本身，称为函数的递归调用

函数的实参传递分为值传递和地址传递

* 值传递：实参单元仍保留并维持原值，没有改变。实参向形参的数据传递是“值传递”，单项传递，只能由实参传给形参，而不能由形参传给实参。实参和形参在内存中占有不同的存储单元，实参无法得到形参的值
* 地址传递：函数的参数是数组名或者指针。传递的是数组的首地址或指针的值，而形参接收到的是地址，即指向实参的存储单元，双向传递，形参和实参占用相同的存储单元，即形参和实参是相同的

## 外部函数与内部函数(extern和static)

extern函数：外部函数，该函数可供其它文件调用，默认使用了extern

static函数：内部函数（静态函数），使函数作用域在本文件中，不能被其他文件调用

## 函数的声明

对库函数(库文件)的声明：# include<文件名>

对自定义函数(头文件)的声明：# include"文件名"

同源文件夹下不需要声明

定义函数文件下的声明：返回值类型 函数名(形参1, 形参2);

从其他文件的声明本质就是该文件中所有函数的声明的复制

## 常用函数

### stdio.h

| 函数                | 功能        |
| ----------------- | --------- |
| printf("占位符",内容)  | 打印语句      |
| scanf(‘格式符“,变量地址) | 键盘录入并赋值变量 |

### math.h

| 函数                     | 功能    | 说明            |
| ---------------------- | ----- | ------------- |
| double pow(num1, num2) | 幂     | 计算num1的num2次幂 |
| double sqrt(num)       | 算术平方根 | 计算num的算术平方根   |
| double ceil(num)       | 上取整   | 对num向上取整      |
| double floor(num)      | 下取整   | 对num向下取整      |
| int abs(num)           | 绝对值   | 计算num的绝对值     |

* 特殊：abs函数使用的标头为<stdio.h>

### time.h

| 函数                   | 功能    | 说明                       |
| -------------------- | ----- | ------------------------ |
| long long time(NULL) | 返回时间戳 | 返回从1970.1.1 0:0:0至今的时间秒值 |

### string.h

| 函数                     | 功能       | 说明                                              | 细节                                                   |
| ---------------------- | -------- | ----------------------------------------------- | ---------------------------------------------------- |
| puts(str)              | 打印字符串    | 打印str内容，并返回指向该str的指针                            | 结尾自带换行                                               |
| gets(str)              | 键盘赋值字符串  | 将输入内容赋值到str中，并返回指向该str的指针                       | 相比scanf能够接收带空格的字符串                                   |
| strlen(str)            | 获取字符串长度  | 从左至'\\0'计算字符串内容的长度，并返回长度值(正)                    | 会单独统计转义字符，但不会统计结束标记符'\\0'。`'\032'`时会统计为一个八进制转义字符     |
| strcat(str1,str2)      | 拼接字符串    | 将str2的内容拷贝拼接到str1中                              | str1的长度必须满足总拼接长，复制内容包括str结尾标记                        |
| strcpy(str1,str2)      | 赋值字符串    | 将str2内容拷贝覆盖到str1                                | 是从str1的结尾标记符开始拼接；str1的长度必须足够拷贝                       |
| strncpy(str1,str2,num) | 覆盖个数特定内容 | 将str2中的num个覆盖到str1中的前num个内容                     |                                                      |
| int strcmp(str1,str2)  | 比较字符串内容  | 自左向右逐个比较字符ASCII码值；如果相等返回0，如果str1>str2返回1，小于返回-1 | 包括大小写比较；相同返回0；不同处第一个字符str1>str2返回正整数，str2\<str1返回负整数 |
| \_strlwr(str)          | 内容转成小写   | 将内容中的大写字母变成小写                                   |                                                      |
| \_struper(str)         | 内容转成大写   | 将内容中的小写字母变成大写                                   |                                                      |

### stdlib.h

#### 随机数

步骤：
```C
# 设置种子
srand(值);

# 获取随机数
int num = rand();
```

* 随机数计算公式：随机数=(31 * 种子值 + 13) % 100
* 默认用1作为种子
* 默认范围：0 ~ 32767

缺点：伪随机，随机数固定为种子值；产生的数字范围固定

改进：
```C
# 将时间戳作为种子
srand(time(NULL));

# 通过对rand()作% 和 +限定范围
int num = rand() % 随机数个数 + 起始值;

例：随机8 ~ 50 范围内的数字
int num = rand() % 43 + 8;
```

* 还是缺点：与时间戳相关

#### 动态内存分配

| 函数                       | 功能       | 说明                                                      |
| ------------------------ | -------- | ------------------------------------------------------- |
| void* malloc(正数值)        | 申请一块连续空间 | 返回该数值个字节空间的首地址，申请失败返回NULL                               |
| void* calloc(个数，每个使用字节数) | 申请一块数组空间 | 申请个数×每个字节的空间大小，并根据每个使用字节数对应数据类型初始化，返回该空间的首地址，申请失败返回NULL |
| void* realloc(指针,数值)     | 修改空间大小   | 修改指针指向的那块空间，指针值不变，申请失败返回NULL                            |
| free(指针)                 | 释放空间     | 释放指针指向的这块空间                                             |

* malloc函数：申请空间过大时，会产生虚拟内存
* realloc函数：
	* 若是申请了新空间，底层会自己处理(释放)原来空间
	* 返回值需要重新设定一个指针来接收值，如果申请的空间失败了，使用原指针接收地址会导致原空间丢失
* free函数：释放空间之后，空间的数据叫做脏数据，可能被清空，可能被修改为其它值
* 返回值都是void\*类型指针，需要转换为其它类型指针才能使用。一般用int\*接收

#### 终止程序

| 函数                    | 功能              | 说明                         |
| --------------------- | --------------- | -------------------------- |
| void exit(int status) | 退出程序并返回状态码给操作系统 | 状态码为 0 表示成功，非零值表示错误(一般用-1) |

# 编译预处理

C语言提供的预处理功能主要有三种：宏定义，文件包含和条件编译

==宏定义==

形式1：`#define 宏名 替换文本`

形式2：`#define 宏名(参数) 替换文本`

说明：宏名习惯用大写字母，但是也可以用小写。宏定义不是C语句，行末不必加分号

形式2实例：
```C
#define f(x) x*x

int a = 6, b = 2;

f(a) + f(b) = 40; //6*6+2*2
f(a+b) = 20; //6+2*6+2
f(a)/f(b) = 36; //6*6/2*2
```

* 方法：先宏替换后计算

==文件包含==

含义：就是指一个源文件可以将另一个源文件的全部内容包含进来，
即将另外的文件包含到本文件中

形式1：`#include<文件名>`

形式2：`#include"文件名"`

* 区别：形式1范围包括系统目录；形式2包括用户目录和系统目录

==条件编译==

形式一：判断标识符是否已定义
```C
#ifdef 标识符
	执行语句1;
#else
	执行语句2;
#endif
```

形式二：判断标识符是否没有定义
```C
#ifndef 标识符
	执行语句1;
#else
	执行语句2;
#endif
```

形式三：类型if语句
```C
#if 表达式
	执行语句1;
#else
	执行语句2;
#endif
```

使用位置：函数之中

# 指针

## 语法

知识前提：每个变量占用对应数据类型个字节，每个字节占用一个内存单元，每个单元都有对应的内存地址，而内存地址占用的字节数与操作系统相关；在不同的操作系统中，内存地址的表示比特位数不同，32位操作系统地址由32个比特(4Byte)构成，总共有2^32次个内存地址，即总共有4G内存可使用，64位操作系统地址由64个比特位(8Byte)构成，总共有2^64次个内存地址，即总共约有17T内存可使用
 
指针：就是地址

指针变量：存储内存地址(首地址)的变量，指向变量，所占用空间大小与存储的数据类型大小相同

指针变量定义：`数据类型 *指针变量名, *指针变量名...;` #C 

指针变量赋值：`指针变量名 = &变量名;` #C 

通过指针赋予/更改数据：`*指针变量名 = 值;` #C 

输出指针变量值：`printf("格式化字符串",*指针变量名);` #C 

输入赋值指针变量值：`scanf("格式化字符串", &变量);`

打印内存地址语句：`printf("%p", &变量/指针);` #C 

* 定义：只定义时指向了一个随机的内存的地址，是野指针，为安全通常要NULL初始化
* 一个变量的指针的含义包括两个方面：一是以存储单元编号表示的 地址，二是指向的存储单元的 数据类型
* 注意：定义的指针类型应该与存储内存的变量类型一样

\*解引用符：除定义指针时为指针标识符，其余为解引用作用，用于**表示指针变量指向的对象**。例：\*p，代表指针变量p指向的对象

数组下标的本质是通过地址偏移后解引用，则有结论：`arr[i] = *(arr+i)`

## 指针作用(作为函数参数和引用字符串)

当函数的形参为指针时，此时传递方式为**地址传递**，实参可以被改变

==作用 1：通过调用函数形参指针，操作实参变量==

问题：当调用函数时传入的实参只能起到值传递作用，不能将实参本身传递，从而对实参进行操作

解决：将函数形参定义为指针，调用函数时传入变量地址，通过地址间接操作实参

==作用2：返回多个函数值==

问题：每一个函数只能return一个值，无法返回多个值

解决：设定两个指针类型变量形参作为函数返回值，当需要调用函数时，将该两个实参利用指针修改作为返回值

==引用字符串==

定义：`char *指针变量名(字符串名) = "内容";` #C 

使用与输出：直接将指针变量名当字符串名使用，不需要解引用

* 字符串指针变量名本质：存储字符数组(字符串)的第一个字符的地址
* 内存存放位置：存储在只读数据段（只读常量区），**数据不可修改**；每定义的字符串占用一块固定的内存地址，可以复用(创建相同字符串时不会创建新内存地址)
* 注意：不能通过数组修改某个字符串中的字符。如：`p[2] = 'a';`，但可以通过修改p指向的地址从而修改整个内容

## 指针运算(步长)

步长：一个步长相当于指针移动一次，至于走了多少字节，与所指向的类型有关(变量、数组、地址)

一维数组中的步长：在一维数组中，指针存储的是列元素的地址，p+1表示走向下一个元素的地址，p-1表示走向上一个元素的地址，每次走一个列元素字节数

二维数组中的步长：在二维数组中，指针存储的是行元素的地址，p+1表示走向下一行的地址，p-1表示走向上一个行的地址，每次走一个行元素字节数

总结：在步长的字节计算中，**走一步是相对于指针当前指向谁而言的**。指针指向变量则走一个数据类型变量字节数；指针指向数组则走数组个数据类型变量字节数；指针指向地址(无论变量还是数组)则走一个操作系统位数字节数

注意：指针可以单个进行增减，但两个指针之间只能进行互减，此时结果表示该两指针的间隔步长

## 其它指针类型

void\*为空类型或无类型指针，指向空类型或不确定类型的数据

特性：void* 类型指针可以与任意类型指针相互转换(隐式转换即可)，但不能通过该指针获取内存地址中的数据和指针运算

注意：定义时指向的是不确定类型数据，赋值后指向了确定类型数据，但自身并没有类型信息(数据有类型指针没类型)

 应用：作为函数形参接收任意类型指针
```C
# 函数功能：交换指定长度的两个变量值
void swap(void *p1, void *p2, int len)
{
	// 把void类型的指针，转成char类型指针
	char *pc1 = p1;
	char *pc2 = p2;

	char tmp = 0;

	// 以字节为单位，一个字节一个字节进行交换
	for (int i = 0; i < len; i++)
	{
		tmp = *pc1;
		*pc1 = *pc2;
		*pc2 = tmp;

		pc1++;
		pc2++;
	}
}
```

* 通过void* 类型指针获取数据方法：将void类型指针转换为其它类型指针利用即可

NULL空指针：不指向任何有效内存地址，用于指针变量初始化，指针变量值为NULL(整数形式为0)，用于判断(与"NULL"和0)不用于打印

野指针：指针指向的空间未分配的指针变量

悬空指针：指针指向的空间已分配的指针变量，但是被释放了

## 二级指针和多级指针

知识前提：指针变量本身也是一个变量，所以也有地址

二级指针：存储了一级指针变量的地址的变量，指向一级指针变量的变量

多级指针：三级及以上的指针

二级指针初始化：`数据类型 **二级指针变量名 = 一级指针变量地址;` #C 

* 数据类型：如果一个变量存储了int类型数据，那么一级指针变量数据类型为int，二级指针变量数据类型也为int

引用运算符与二级指针：

* pp：表示一级指针变量的地址，指向一级指针变量
* \*pp：表示变量的地址，指向变量
* \*\*pp：表示变量

作用一：利用二级指针修改一级指针记录的内存地址

```C
int a = 10;
int b = 20;
int *p = &a;
int **pp = &p;

// 未修改前的记录数值
printf("%d\n", *p); //10
printf("%p\n", p); //0000002585CFF864

// 通过二级指针修改一级指针记录的内存地址
*pp = &b;

printf("%d\n", *p); //20
printf("%p\n", p); //0000002585CFF884
```

作用二：利用二级指针获取到变量中记录的数据

```C
int a = 10;
int* p = &a;
int** pp = &p;

printf("%d", **pp); //10
```

## 数组与指针

### 语法

知识前提：数组名的本质是一个地址

**数组名退化：数组名直接使用是会退化为指向该数组中首元素的指针。一维数组中首元素为变量，为指向变量的指针；二维数组中首元素为一维数组，为指向整个一维数组的指针**。如果没有退化则会表示整个数组地址

没有退化情况：作为`sizeof` 运算符的操作数和地址运算符 `&` 的操作数

==数组元素的指针变量==

含义：存储了数组中元素地址的指针变量，指向变量，本质还是一个存储变量地址的指针变量

实例：
```C
int arr[] = { 1,2,3,4,5,6,7,8 };
int *p = arr;
```

* 步长：指向变量，一步长为一个变量长
* 数组名发生了退化

数组引用：`a[i]`（下标法）或 `*(a+i)`（指针法）

**理解**：a先退化为第一个元素的地址，然后偏移i步长到新地址，最后对地址解引用。**总共三阶段：退化、偏移、解引用**

==数组指针==

含义：存储了整个数组地址的指针变量，指向整个数组，本质是一个存储了整个数组地址的指针变量

初始化：`数据类型 (*指针变量名)[数组长度] = 数组地址;` #C 

* 步长：存储的是一个数组的地址，一步为一个数组的大小

```C
int arr[5] = { 1,2,3,4,5 };
int (*p)[5] = &arr;
```

* p等同于&arr，存储整个数组地址，指向整个数组；\*p等同于arr，存储了&arr[0]地址，指向a[0]

(数组)数组指针使用注意点：\*数组指针为数组名使用方式，存储的是首元素地址，指向首元素

==指针数组==

含义：存储了多个元素为指针的数组，本质是一个数组

初始化：`数据类型 *数组名[长度] = {值1,值2,...};` #C 

* 步长：数组名指向的是一个地址，大小与操作系统有关

作用：存储若干个字符串。例：`char *strs[4] = {"abcd", "efgh", "ijkl", ...};`

(记忆 )区分定义数组指针与指针数组：符号结合优先级：`( ) > [ ] > *`，哪个先结合本质就是谁，且命名时在后面

### 指针在数组中的作用

#### 访问元素

通过数组指针访问数组元素
```C
# 通过指针运算获取第二个索引值
int arr[] = { 1,2,3,4,5,6,7,8 };
int *p = arr;
printf("%d", *(p + 1));
```

#### 数组中的指针作为函数参数

| 实现  | void test(int arr[] ,int sz){} | void test(int *arr ,int sz){} |
| --- | ------------------------------ | ----------------------------- |
| 调用  | test(&arr,sz);                 | test(arr,sz);                 |

* 区别：都是使用指针作为形参，但前一个`int arr[]`是将整个数组地址作为地址传递，而后一个`int *arr`是将数组中首元素地址作为地址传递

#### 指针遍历数组

##### 一维数组遍历

方法一：指针变量
```C
int arr[] = { 10,20,30,40,50 };
int len = sizeof(arr) / sizeof(int);
int *p = arr;

for (int i = 0; i < len; i++)
{
	printf("%d\n", *p++);
}
```

方法二：数组指针
```C
int arr[] = { 10,20,30,40,50 };
int len = sizeof(arr) / sizeof(int);
int (*p)[len] = &arr;

for (int i = 0; i < len; i++)
{
	printf("%d\n", (*p)[i]);
}
```

注意：\*和++、--符号为同级运算符，但执行顺序是从右向左。例：`*++p`，为先++p后*

##### 二维数组遍历

在二维数组中，不同表达形式的语句具有不同含义，但所指向的地址值可能相同

例：`int a[][4];`，有以下几种不同表达形式（同含义同地址）：

| 表示形式                             | 含义               | 地址   |
| -------------------------------- | ---------------- | ---- |
| a                                | 0行首地址            | 2000 |
| a[0]，\*(a+0)，\*a                 | 0行0列元素地址         | 2000 |
| a+1，&a[1]                        | 1行首地址            | 2016 |
| a[1]，\*(a+1)                     | 1行0列元素a[1][0]的地址 | 2016 |
| a[1]+2，\*(a+1)+2，&a[1][2]        | 1行2列元素a[1][2]的地址 | 2024 |
| \*(a[1]+2)，\*(\*(a+1)+2)，a[1][2] | 1行2列元素a[1][2]的值  | 元素值  |

###### 指针变量

方法：通过取列1元素地址，进行步长遍历
```C
int arr[3][4] = { 1,2,3,4,5,6,7,8,9,10,11,12 };

int *q = &arr[0][0]; //第一种写法
int *q = arr[0]; //第二种写法
for (int i = 0; i < 12; i++)
{
	printf("%d\n", *(q + i));
}
```

* 第二种写法：arr先退化为指向整个一维数组地址，然后0步长获取第一个一维数组地址，最后\*解引用获取一维数组名，再退化为指向0列元素的指针

###### 数组指针

方法：通过一维数组的指针遍历
```C
int arr[3][5] = { {1,2,3,4,5},{11,22,33,44,55},{111,222,333,444,555} };
int (*p)[5] = arr;

for (int i = 0; i < 3; i++)
{
    for (int j = 0; j < 5; j++)
    {
        printf("%d ", *(*p+j));
    }
    printf("\n");
    p++;
}
```

* `*(*p+j)`理解：先`*p`获得一维数组，此时会退化为指向列0元素的指针，然后偏移j步长到新地址，最后\*解引用获得变量值
* 拓展：存储该二维数组地址的指针变量定义：`int(*p)[3][5] = arr;`

###### 指针数组

```C
int arr1[] = {1,2,3};
int arr2[] = {1,2,3,4,5};
int arr3[] = {1,2,3,4,5,6,7,8,9};

int len1 = sizeof(arr1) / sizeof(int);
int len2 = sizeof(arr2) / sizeof(int);
int len3 = sizeof(arr3) / sizeof(int);
int lenArr[] = {len1,len2,len3};

int *arr[3] = { arr1,arr2,arr3 };
for (int i = 0; i < 3; i++)
{
    for (int j = 0; j < lenArr[i]; j++)
    {
        printf("%d ", arr[i][j]);
        // printf("%d ", *(arr[i]+j ));
    }
    printf("\n");
}
```

* `arr[i][j]`理解：arr先退化为指向列0元素(新数组)的指针，然后偏移i步长到新地址，之后\*解引用获得新元素(数组)，新数组退化为指向首元素的指针，然后偏移j步长，最后\*解引用获得变量值

## 函数与指针

知识前提：函数名本身也是个地址

==函数指针==

含义：是一个存储了函数地址的指针变量，指向函数

函数指针变量定义：`返回值类型 (*指针变量名)(形参数据类型)`； #C 

* 返回值类型：应与指向函数的返回值类型一致
* 形参数据类型：与函数形参列表中的数据类型一致，但可以不用写定义变量名

初始化：`返回值类型 (*指针变量名)(形参列表/数据类型) = 函数地址;` #C 

* 函数地址：可以是直接的`函数名`(推荐)，也可以是`&函数名`

调用：`[返回值赋值 =] 函数指针变量名(实参1, 实参2...);` #C 

* 使用：可以直接像普通函数调用一样(推荐)，也可以在调用前先`*函数名`

注意：函数指针的运算无任何意义

实例：
```C
void main()
{
	// 定义并初始化函数指针
    int (*q)(int, int) = sum;

    // 调用函数指针
    int res = q(1,2);

}

int sum(int num1, int num2)
{
    return (num1 + num2);
}
```

==指针函数==

含义：指的是函数的返回值是一个指针

### 作用——作为函数参数和函数返回值

作为参数优点：通过函数参数，将不同函数指针传入函数，从而灵活地调用不同函数

```C
add、sub、mul、div函数

void calc(int (*p)(int,int))
{
	printf("请输入两个数：");
	int a, b;
	scanf("%d%d", &a, &b);
	int res = p(a,b);
}

void main()
{
	printf(""请输入要实现的功能数字：\n);
	int num;
	scanf("%d", &num);
	switch (num)
	{
	case 1:
		calc(add);
		break;
	case 2:
		calc(sub);
		break;
	case 3:
		calc(mul);
		break;
	case 4:
		calc(div);
		break;
	}
	default:
		break;
}
```

### main函数参数

main函数其实包含了三个参数，只是没有显示而已

main函数完整格式：
```C
int main(int argc, char *argv[], char *envp[])
{
	;
}
```

* int agrc：记录命令行参数个数
* char \*argv[]：用字符串数组存储命令行的参数，每一个字符串表示命令行中的参数；最后一个元素以NULL结尾
* char \*envp[]：存储环境变量的数组

# 自定义数据类型

## 结构体类型——struct

结构体类型：由多种数据类型数据聚合而成的整体，每一个数据是结构体的成员，是一种数据结构

结构体变量：采用结构体类型创建的变量

作用：存储多种数据数据作为一个整体，用于管理某个对象信息

### 语法

声明结构体类型：
```C
struct 结构体名
{
	数据类型1 成员名1;
	数据类型2 成员名2;
	...
};
```

* 结构体内容只需定义变量，不需要赋值
* 声明的位置一般跟函数同级，也可以定义在函数内
* 结构体名一般首字母大写
* 声明并定义：可以在};之间创建结构体变量并赋值，但不推荐
* 可以省略结构体名从而定义匿名结构体，缺点是只能在后面创建结构体变量(不推荐)

定义结构体变量：`struct 结构体名 结构体变量名;` #C 

定义并(顺序)赋值：`struct 结构体名 结构体变量名 = {成员值1,成员值2...};` #C 

定义并(自定义顺序)赋值：`struct 结构体名 结构体变量名 = {.成员1 = 成员值1, .成员2 = 成员值2,...}` #C 

* 定义和创建结构体时将(struct 结构体名)当作整体(一种数据类型)使用
* 定义了结构体变量而为赋值时按对应数据类型赋予默认值

使用/赋值成员：`结构体变量名.成员 [= 值];` #C 

结构体变量互相赋值：`结构体变量名1 = 结构体变量名2;` #C 

成员运算符（.）：用于结构体变量访问成员

示范：
```C
# 目的：创建一个学生结构体，创建三个学生并打印相关信息
struct  Student
{
	char name[100];
	int age;
};

int main()
{
	struct Student stu1 = { "dayi",11 };
	struct Student stu2 = { "daer",12 };
	struct Student stu3 = { "dasan",13 };
	
	struct Student arr[3] = { stu1,stu2,stu3 }; //结构体类型数组

	for (int i = 0; i < 3; i++)
	{
		struct Student temp = arr[i]; //结构体类型变量
		printf("学生的名字为：%s，年龄为：%d\n", temp.name, temp.age);
	}
}
```

### 结构体嵌套

含义：结构体中的数据类型包含另外的结构体类型

第二层声明位置：嵌套的结构体定义与第一层同级即可

定义并赋值(第一、二层)：`struct 结构体名1 结构体变量名1 = {值11，值22,{值21，值22...}...}` #C 

第二层结构体变量定义位置：在第一层结构体的定义中

使用/赋值第二层成员：`结构体变量名1.结构体变量名2.成员 [= 值]` #C 

### 结构体数组

含义：存储结构体的数组

创建并赋值：`struct 结构体名 结构体数组名[结构体变量个数] = {{结构体1成员值列表},{结构体2成员值列表},...}` #C 

结构体数组成员访问：`结构体数组名[i].成员;` #C 

### 结构体指针

#### 结构体变量指针

结构体变量本身也是一个变量，故也有地址

结构体变量名本身是一个地址

含义：存储结构体变量地址的指针变量，指向结构体变量

结构体指针变量定义：`struct 结构体名* 结构体指针变量名;` #C 

结构体指针变量定义并赋值：`struct 结构体名* 结构体指针变量名 = 结构体变量名;` #C 

结构体指针变量访问成员1：`*结构体指针变量名.成员 [= 值];` #C 

结构体指针变量访问成员2：`结构体指针变量名 -> 成员 [= 值];` #C 

* 指向运算符（->）：用于结构体指针变量(地址)访问结构体成员

#### 结构体数组与指针

含义：存储结构体变量地址的指针变量，指向结构体变量

定义：`struct 结构体名* 结构体指针变量名` #C 

定义与赋值：`struct 结构体名* 结构体指针变量名 = 结构体数组名` #C 

* 存储的是退化了的结构体数组名，是数组中第一个结构体变量的地址

```C
struct Student
{
	int age;
	char name[20];
};

int main()
{
	struct Student s[3] = { {10,"zhangsan"},{12,"lisi"},{15,"wangwu"} };//定义一个结构体数组
	struct Student* sp = s;//定义一个存储结构体数组的变量
	for (int i = 0; i < 3; i++)
	{
		printf("%d %s\n", sp->age, sp->name);
		sp++;
	}
}
```

#### 在函数中的作用——作为实参与形参

```C
typedef struct Student
{
	char name[100];
	int age;
} stu;

void change(stu s);

int main()
{
	stu stu1 = { "dayi",11 };

	change(stu1);
	printf("修改完后新的学生名：%s", stu1.name); //结果没有变化

	newChange(&stu1);
	printf("修改完后新的学生名：%s", stu1.name); //结果改变了

}

//不用指针传递结构体
void change(stu s)
{
	printf("学生的名字为：%s，年龄为：%d\n", s.name, s.age);

	printf("输入修改后的学生名：\n");
	scanf("%s", s.name);

	printf("输入修改后的学生年龄：\n");
	scanf("%d", &(s.age));

}

//使用指针传递结构体
void newChange(stu* p)
{
	printf("学生的名字为：%s，年龄为：%d\n", (*p).name, (*p).age);

	printf("输入修改后的学生名：\n");
	scanf("%s", (*p).name);

	printf("输入修改后的学生年龄：\n");
	scanf("%d", &((*p).age));

}
```

* 创建的形参结构体函数的定义需要在结构体定义后面

### 结构体内存对齐

问题：在定义一个结构体后，所在的内存并不是所有数据类型字节总和

数据类型占用字节规则：

* 从上往下存放数据字节，从0开始
* 每一个变量所在第一个字节要在自己字节类型整数倍的内存地址上，不满足则跳过用空字节补充内存
* 所有变量占完内存后，总有一个字节用于内存对齐(只有一个数据类型则不需要对齐)，该字节需要放在该结构体所有数据总字节数的整数倍的内存地址上

示例：
```C
struct num
{
	double a;
	char b;
	int c;
	char d;
}
```

* 对齐说明：从0开始
	* double a：[0,7]
	* char b：[8,8]
	* 填充：[9,11]
	* int c：[12,15]
	* char d：[16,16]
	* 填充：[17,23]
	* 内存占用：总共占用24个字节
* 空间大小：结构体所占内存长度是各成员所占的内存长度之和+内存对齐

计算总字节数语句：`printf("%zu",sizeof(结构体变量名));`

总结作用：在结构体中定义数据时，将小字节数据类型放前，大字节数类型放后面

## 共用体/共同体/联合体——union

共用体类型：具有多种数据类型的整体，其中每一个数据都是一个成员，是一种数据结构

共用体变量：采用共用体类型创建的变量

作用：能够接收与成员数据类型一致的数据值

声明共用体：
```C
union 共用体名
{
	定义变量1;
	定义变量2;
	...
}
```

* 一个变量名对应一种数据类型，变量名不可以重复
* 定义位置放与函数同级即可
* 使用时将(union 共用体名)联合为数据类型

定义共用体变量：`union 公用体名 共用体变量名;` #C 

定义并赋值(自动识别)1：`union 共用体名 共用体变量名 = {值}` #C 

定义并赋值(特定成员)2：`union 共用体名 共用体变量名 = {.成员 = 值}` #C 

使用/赋值：`共用体变量名.成员 [= 值];` #C 

共用体变量互相赋值：`共用体变量名1 = 共用体变量名2;` #C 

* 每次只能赋值其中一个成员，后一个赋值会覆盖前面的值；且只能使用最后一个被赋值的成员
* 赋值什么成员类型变量，取用时也要按对应变量格式输出，不然会发生数据类型转换

特点：

* 内存空间：定义里的所有变量占用同一个内存空间（所以变量的内存地址一样），且所占空间大小为最大成员的长度(受内存对齐影响)
	* 假设有int a、double b、char c[100]三个变量的共用体，先取到最大变量所占字节数100，然后拿到最大数据类型所占字节数8，内存对齐（总大小为最大数据类型所占字节数的整数倍），得出总内存=104字节

作用：可以作为结构体的一个成员，从而使该成员可以接收不同类型数据值

## 枚举——enum

枚举：具有多个整型常量的整体，每一个常量称为为枚举元素或枚举常量，是一种数据类型

枚举变量：采用枚举类型创建的变量

作用：只能使用枚举常量对枚举变量赋值

枚举定义：
```C
enum 枚举变量名
{
	常量1,
	常量2,
	...
}
```

* 每一个枚举元素代表一个整数，默认由0开始，每一位整数值为前一位整数值+1；可自定义默认整数值(没有整数值的按前一位赋默认整数值)
* 定义的常量可以拿来直接使用，但是值为对应整数值代表

定义枚举变量：`enum 枚举名 枚举变量名;` #C 

定义枚举变量并赋值：`enum 枚举名 枚举变量名 = 常量1||常量2||...;` #C 

使用枚举变量：`枚举变量名;` #C 

*  使用时为赋值的枚举常量所对应的整数值
## typedef声明新类型名

typedef对已有的数据类型重新声明名字，是在编译时处理，与#define不同

无符号int：`typedef unsigned int newname;`

数组：`typedef int newname[10];`

指针：`typedef int *p;`

函数指针：`typedef (*newname)(int,int);`

结构体：
```c
typedef struct S
{
	
}newname;
```

总结定义格式：由原来定义变量时的格式前加typedef，则定义的变量名就改为新类型名

# 内存结构

![[Pasted image 20240729011604.png]]

* 静态区：包括初始化静态区和未初始化静态区，存储了由static修饰的变量
* 栈：先进后出，main函数先加载到栈中，之后加载其它函数，运行完所有后，先释放其它函数在main函数；定语的变量/数组生命周期随函数结束；包括存放指向其它区中变量/数组的地址
* 常量区：字符串指针定义法时数据存放处
* 堆：远比栈空间大，申请大数组时建议放堆区

根据存储区分类：

* 静态存储区：堆、静态区、常量区
* 动态存储区：栈

# 读写文件

文件有不同的类型,在程序设计中，主要用到两种文件：程序文件和数据文件

程序文件：包括源程序文件(后缀为.c)、目标文件(后缀为.obj)、可执行文件(后
缀为.exe)等。这种文件的内容是程序代码

程序文件产生过程：[[Pasted image 20240730162621.png|182]]

数据文件：文件的内容不是程序，而是供程序运行时读写的数据，如在程序运行过程中输出到磁盘(或其他外部设备)的数据,或在程序运行过程中供读入的数据

根据数据的组织形式，数据文件又可分为ASCII文件和二进制文件

数据在内存中是以二进制形式存储的

二进制文件：如果不加转换地输出到外存，就是二进制文件，可以认为它就是存储在内存的数据的映像，所以也称之为映像文件(image file)

ASCII文件：在外存中以ASCII码形式存储，需要在存储前进行转换，每一个字节放一个字符的ASCII代码，ASCII文件又称文本文件

==顺序读写==

文件指针定义：`File *文件指针名;` #C 

| 返回值   | 函数                              | 功能           | 说明                                                                      |
| ----- | ------------------------------- | ------------ | ----------------------------------------------------------------------- |
| FILE* | fopen("文件路径","使用方式")            | 打开文件并赋予文件权限  | 返回一个该文件的指针，如果r、a模式下文件不存在则报错返回NULL空指针                                    |
| int   | fgetc(FILE\*)                   | 读取一个字符       | 一次读取一个字符，读取成功返回读取字符，读取失败返回EOF(-1)                                       |
| int   | fputc(字符,FILE*)                 | 写入字符         | 一次写入一个字符，输出成功返回输出字符，输出失败返回EOF(-1)                                       |
| char* | fgets(数组,内容大小,FILE\*)           | 读取一行内容       | 一次读取一行内容('\\n'识别)，读取内容到赋给数组(最后加'\\0')，然后读取指向下一行，并返回该数组的指针，读取失败返回NULL空指针 |
| int   | fputs(字符串,FILE*)                | 写入一个字符串      | 一次写入一个字符串(不包括末尾'\\0'，不会换行)，成功写入返回0，写入错误则返回非0值                           |
|       | fprintf(FILE*,占位符,变量)           | printf方法写入数据 | 后两个参数同printf参数一样，将原printf打印的内容写入文件                                      |
|       | fscanf(FILE*,格式符,&变量)           | scanf方法读取数据  | 后两个参数同scanf参数一样，将文件数据录入变量中                                              |
| int   | fread(数组地址,每次读取字节数,读取次数,FILE*)  | 二级制格式读取字节数组  | 总共读取每次数×一次数字节，将读取的内容赋值给数组地址指向数组，读取成功返回读取次数，失败返回0                        |
| int   | fwrite(数组地址,每次写入字节数,写入次数,FILE*) | 二级制格式写入多个内容  | 将字节数组中内容按每次写入字节数多次写入，写入成功返回写入次数，失败返回0                                   |
| int   | fclose(FILE*)                   | 关闭文件         | 使文件指针不在指向文件；执行成功返回0，失败返回EOF(-1)                                         |

* FILE为typedef struct重命名结构体变量，位于头文件<stdio.h>中
* fopen函数：文件路径使用\\\\
* fread函数：
	* 读取所有的内容时，换行符占一个字节，中文两个
	* 数组大小：
		* 如果设置大于内容字节数一次读完，则会乱码(空数组内容)
		* 如果设置多次读取拼接，则中文拼接时可能接不上，半个中文可能和前面的字节连上
		* 具体情况设置具体大小

注意：文件读取文字时要将文件改为ANSI编码方式

| 使用文件方式 | 说明          |
| ------ | ----------- |
| "r"    | 只读模式        |
| "w"    | 覆盖写入模式      |
| "a"    | 追加写入模式      |
| "rb"   | 只读模式(二进制)   |
| "wb"   | 覆盖写入模式(二进制) |
| "ab"   | 追加写入模式(二进制) |

* 记忆：r-读、w-写、a-追加、+-读写、b-二进制文件
* 当有w时，如果文件不存在则会创建文件

==随机读写==

文件位置标记：读写时会指向下一个字符位置，除了fgets会指向下一行

注意：在同时打开文件的读写流时，文件中的读和写操作共享同一个文件位置标记

| 函数                      | 功能     | 说明                                       |
| ----------------------- | ------ | ---------------------------------------- |
| rewind(FILE* )          | 标记指向开头 |                                          |
| fseek(FILE*,位移量(L),起始点) | 改变标记位置 | 位移量是相对于起始点而言的，起始点0表示文件开头，1表示当前位置，2表示文件末尾 |
| long ftell(FILE*)       | 测定标记位置 | 成功指向返回相当于文件开头位移量的值，失败返回-1L               |

==文件出错检测==

| 函数              | 功能                   | 说明           |
| --------------- | -------------------- | ------------ |
| feof(FILE*)     | 检测当前标记位置是否为文件结尾      | 是则返回1，不是返回0  |
| ferror(FILE*)   | 检测fopen返回的指针是否发生错误标志 | 是则返回非零，不是返回0 |
| clearerr(FILE*) | 置错误标志和文件结尾标志为0       |              |

* 随机读写的函数也会改变EOF标志

实例：拷贝文件
```C
FILE* file1 = fopen("读取文件路径");
FILE* file2 = fopen("写入文件路径");

char arr[1024];
int n;
while ((n = fread(arr, 1, 1024, file1) != 0))
{
	fwrite(arr, 1, 1024, file2);
}

fclose(file1);
fclose(file2);
```

